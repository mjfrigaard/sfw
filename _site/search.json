[
  {
    "objectID": "golem.html",
    "href": "golem.html",
    "title": "The golem framework",
    "section": "",
    "text": "The golem package provides many options for R programmers experienced with creating R packages, but who are looking to streamline their application development.1"
  },
  {
    "objectID": "golem.html#getting-started",
    "href": "golem.html#getting-started",
    "title": "The golem framework",
    "section": "Getting started",
    "text": "Getting started\nTo create a new golem app from the console, enter the following:\n\ninstall.packages(\"golem\")\nlibrary(golem)\ngolem::create_golem(path = \"gap\")\n\nIf creating a golem app from RStudio’s New Project Wizard, the following defaults are available:\n\n\n\n\n\n\n\nFigure 1: Creating a new golem shiny app"
  },
  {
    "objectID": "golem.html#package-files",
    "href": "golem.html#package-files",
    "title": "The golem framework",
    "section": "Package files",
    "text": "Package files\nThe initial folder structure for a new golem application is below:\n\ngap\n    ├── DESCRIPTION\n    ├── NAMESPACE\n    ├── R\n    │   ├── app_config.R\n    │   ├── app_server.R\n    │   ├── app_ui.R\n    │   └── run_app.R\n    ├── dev\n    │   ├── 01_start.R\n    │   ├── 02_dev.R\n    │   ├── 03_deploy.R\n    │   └── run_dev.R\n    ├── inst\n    │   ├── app\n    │   │   └── www\n    │   │       └── favicon.ico\n    │   └── golem-config.yml\n    ├── man\n    │   └── run_app.Rd\n    └── gap.Rproj\n\nThe dev/ folder contains golem‘s ’guided tour’ scripts. These contain functions to help guide application development.\n\ndev/01_start.R opens automatically\n\n\ngap/dev/\n    ├── 01_start.R\n    ├── 02_dev.R\n    ├── 03_deploy.R\n    └── run_dev.R\n\n1 directory, 4 files\n\n\ndev/run_dev.R is for running the ‘development version’ of the application.\n\nIf you are familiar with R package development, you can think of the dev/ scripts as a ‘Shiny app-package development checklist.’\n\nDESCRIPTION: In the dev/01_start.R script, users build a DESCRIPTION file with golem::fill_desc()\n\nfill_desc() uses the desc package and the sections are entered in a key = \"value\" format\n\n\ngolem::fill_desc(\n  pkg_name = \"gap\",\n  pkg_title = \"An example goelm app\",\n  pkg_description = \"A working example of the golem package.\",\n  author_first_name = \"Martin\",\n  author_last_name = \"Frigaard\",\n  author_email = \"mjfrigaard@pm.me\",\n  repo_url = NULL # The URL of the GitHub Repo (optional)\n)\n\n\nIn dev/02_dev.R, the attachment::att_amend_desc() will “Amend DESCRIPTION with dependencies read from package code parsing”.\n\n\nattachment::att_amend_desc()\n\n\nIf attachment is not installed, use install.package('attachment')\n\n\ndev/01_start.R contains the usethis functions for for creating common package development files:\n\nLICENSE\n\nusethis::use_mit_license()\n\nREADME\n\nusethis::use_readme_rmd()\n\nCode of Conduct\n\nusethis::use_code_of_conduct()\n\nLifecycle badge\n\nusethis::use_lifecycle_badge(\"Experimental\")\n\nNEWS.md\n\nusethis::use_news_md(open = FALSE)\n\nGit\n\nusethis::use_git()\n\n\n\ngolem files\nThe golem functions in dev/01_start.R are for setting the golem options and using recommended tests.\n\nOptions\n\ngolem::set_golem_options()\n\nTests (with testthat)\n\ngolem::use_recommended_tests()\n\nFavicon\n\ngolem::use_favicon()\n\nHelper functions: golem::use_utils_ui() and golem::use_utils_server() create golem’s UI (R/golem_utils_ui.R) and server (R/golem_utils_server.R) utility functions in the R/ folder\n\n\n\n\n\n\n\ngolem gives away lots of free code!\n\n\n\n\n\n\nBoth R/golem_utils_ui.R and R/golem_utils_server.R contain a lot of helper functions that come in handy if you’re tired of writing out particular function names (like reactiveValuesToList() or column(width = 6)/column(width = 12))\nCheck them out here:\n\ngolem_utils_ui.R\ngolem_utils_server.R\n\n\n\n\n\n\n\nApp Code\nThe dev/02_dev.R file covers the ‘development’ phase of a new a golem app-package. Most of the golem functions in dev/02_dev.R will create files in the R/ and inst/ folders.\nThe two pre-configured UI and server functions are in R/app_ui.R and R/app_server.R:\nR/\n├── app_config.R\n├── app_server.R\n├── app_ui.R\n└── run_app.R\n\n1 directory, 4 files\n\napp_ui() and app_server() are golem-flavored UI and server files, which means they include the @noRd tag and include additional golem utilities.\n\n#' The application User-Interface\n#'\n#' @param request Internal parameter for `{shiny}`.\n#'     DO NOT REMOVE.\n#' @noRd\napp_ui &lt;- function(request) {\n  tagList(\n    # Leave this function for adding external resources\n    golem_add_external_resources(),\n    # Your application UI logic\n    fluidPage(\n      h1(\"gap\")\n    )\n  )\n}\n\n\n#' The application server-side\n#'\n#' @param input,output,session Internal parameters for {shiny}.\n#'     DO NOT REMOVE.\n#' @import shiny\n#' @noRd\napp_server &lt;- function(input, output, session) {\n  # Your application server logic\n}\n\nIf you do some digging, you’ll find most of these golem utilities are wrappers for shiny and usethis functions. For example, golem_add_external_resources() is a wrapper for shiny::addResourcePath() and htmltools::htmlDependency():\n\n#' Add external Resources to the Application\n#'\n#' This function is internally used to add external\n#' resources inside the Shiny application.\n#'\ngolem_add_external_resources &lt;- function() {\n  add_resource_path(\n    \"www\",\n    app_sys(\"app/www\")\n  )\n\n  tags$head(\n    favicon(),\n    bundle_resources(\n      path = app_sys(\"app/www\"),\n      app_title = \"gap\"\n    )\n    # Add here other external resources\n    # for example, you can add shinyalert::useShinyalert()\n  )\n}\n\n\nAnd app_sys() is a wrapper for system.file():\n\n\n#' Access files in the current app\n#'\n#' NOTE: If you manually change your package name in the DESCRIPTION,\n#' don't forget to change it here too, and in the config file.\n#' For a safer name change mechanism, use the `golem::set_golem_name()` function.\n#'\n#' @param ... character vectors, specifying subdirectory and file(s)\n#' within your package. The default, none, returns the root of the app.\n#'\n#' @noRd\napp_sys &lt;- function(...) {\n  system.file(..., package = \"gap\")\n}\n\nrun_app.R is an exported function that is available for me to run my app after I’ve installed the package:\n\nlibrary(gap)\ngap::run_app()\n\n\n\nCreating code files\n\ngolem has wrappers for creating modules and helper functions in the R/ folder:\n\n## Add modules ----\n## Create a module infrastructure in R/\ngolem::add_module(name = \"name_of_module1\", with_test = TRUE) \ngolem::add_module(name = \"name_of_module2\", with_test = TRUE) \n\n## Add helper functions ----\n## Creates fct_* and utils_*\ngolem::add_fct(\"helpers\", with_test = TRUE)\ngolem::add_utils(\"helpers\", with_test = TRUE)\n\n\nwith_test = TRUE ensures these functions will also create test files in tests/\n\n\n\n\nConfiguration\n\nThe R/app_config.R file contains two functions: app_sys() (covered above) and get_golem_config(), which reads the inst/golem-config.yml configuration file\n\ndefault:\n  golem_name: gap\n  golem_version: 0.0.0.9000\n  app_prod: no\nproduction:\n  app_prod: yes\ndev:\n  golem_wd: !expr here::here()\n\n\ngolem-config.yml gives access to the app version, name, and (development) working directory, so it can be used to add “production-only elements” and is “shareable across golem projects”\n\n\nget_golem_config() is also included in the R/app_config.R file\n\n# Read App Config\nget_golem_config &lt;- function(\n  value,\n  config = Sys.getenv(\n    \"GOLEM_CONFIG_ACTIVE\",\n    Sys.getenv(\n      \"R_CONFIG_ACTIVE\",\n      \"default\"\n    )\n  ),\n  use_parent = TRUE,\n  # Modify this if your config file is somewhere else\n  file = app_sys(\"golem-config.yml\")\n) {\n  config::get(\n    value = value,\n    config = config,\n    file = file,\n    use_parent = use_parent\n  )\n}\n\n\n\n\nTest files\ngolem::use_recommended_tests() creates the tests/ folder and a series of unit tests in the dev/01_start.R script. This function is essentially a wrapper around usethis::use_testthat(), but with some additional ‘recommendations’.2\n\ngolem::use_recommended_tests() adds the spelling package to our DESCRIPTION and updates the WORDLIST\nThe tests folder uses the testthat framework\n\ntests/testthat/\n            ├── test-golem-recommended.R\n            ├── test-golem_utils_server.R\n            └── test-golem_utils_ui.R\n\n2 directories, 4 files\n\n\n\n\nExternal files\nThe inst/ file initially has the following contents/structure:\ninst/\n  ├── WORDLIST\n  ├── app/\n  │   └── www/\n  │       └── favicon.ico\n  └── golem-config.yml \nThe golem-config.yml file is covered above, but the inst/app/ folder works just like the inst/extdata folder (it is loaded when the package is installed and makes these files available to the application).\ndev/02_dev.R includes golem wrappers for including CSS, JavaScript, and SASS files to the inst/app/www/ folder:\n\ngolem::add_js_file(\"script\")\ngolem::add_js_handler(\"handlers\")\ngolem::add_css_file(\"custom\")\ngolem::add_sass_file(\"custom\")\n\n\n\nDeploy\nThe final script in the guided tour contains functions for deploying a new application to Posit Connect or Docker (it opens automatically after completing the dev/02_dev.R)\nRStudio (Posit) Connect \n\ngolem::add_rstudioconnect_file(), golem::add_shinyappsio_file(), and golem::add_shinyserver_file()\n\nDocker \n\ngolem::add_dockerfile_with_renv() and golem::add_dockerfile_with_renv_shinyproxy()\nI’ll deploy my app using shinyapps.io, so after running golem::add_shinyappsio_file() I will see the following output and a new app.R file:\n\ngolem::add_shinyappsio_file()\n── Creating _disable_autoload.R ──────────────────────────────────────────────────────\n✔ Created\n✔ Setting active project to '/Users/mjfrigaard/projects/gap'\n✔ Adding '^app\\\\.R$' to '.Rbuildignore'\n✔ Adding '^rsconnect$' to '.Rbuildignore'\n✔ Adding 'pkgload' to Imports field in DESCRIPTION\n• Refer to functions with `pkgload::fun()`\n✔ File created at /Users/mjfrigaard/projects/gap/app.R\nTo deploy, run:\n• rsconnect::deployApp()\n\n• Note that you'll need to upload the whole package to ShinyApps.io\n\napp.R contents\n\n# Launch the ShinyApp (Do not remove this comment)\n# To deploy, run: rsconnect::deployApp()\n# Or use the blue button on top of this file\n\npkgload::load_all(export_all = FALSE, helpers = FALSE, attach_testthat = FALSE)\noptions( \"golem.app.prod\" = TRUE)\ngap::run_app() # add parameters here (if any)"
  },
  {
    "objectID": "golem.html#building-golem-apps",
    "href": "golem.html#building-golem-apps",
    "title": "The golem framework",
    "section": "Building golem apps",
    "text": "Building golem apps\nBuilding an application with golem is very similar to developing an R package. However, golem streamlines some of the R package development processes into wrapper functions. The sections below cover creating modules, utility functions, and tests in a new golem app:\n\nModules\nNew modules can be created with golem::add_module(). I’ve provided an example below to demonstrate the variable arguments and options:\nadd_module(name = 'name', \n           fct = 'fun', \n           utils = 'fun', \n           with_test = TRUE, \n           export = TRUE)\nThe code above creates the following files:\n\nname = ‘name’: creates R/mod_name.R, a boilerplate Shiny module (ui and server functions)\n\n\nshow/hide R/mod_name.R\n#' name UI Function\n#'\n#' @description A shiny Module.\n#'\n#' @param id,input,output,session Internal parameters for {shiny}.\n#'\n#' @rdname mod_name\n#' @export \n#'\n#' @importFrom shiny NS tagList \nmod_name_ui &lt;- function(id){\n  ns &lt;- NS(id)\n  tagList(\n\n  )\n}\n\n#' name Server Functions\n#'\n#' @rdname mod_name\n#' @export \nmod_name_server &lt;- function(id){\n  moduleServer( id, function(input, output, session){\n    ns &lt;- session$ns\n\n  })\n}\n\n## To be copied in the UI\n# mod_name_ui(\"name_1\")\n\n## To be copied in the server\n# mod_name_server(\"name_1\")\n\n\nfct = ‘fun’ and utils = ‘fun’: creates two empty R files in the R/ folder (R/mod_name_fct_fun.R and R/mod_name_utils_fun.R) with the same prefix as the module.\nwith_test = TRUE: creates tests/testthat/test-mod_name.R, a test file for the module with the following boilerplate tests:\n\n\nshow/hide tests/testthat/test-mod_name.R\ntestServer(mod_name_server,\n  # Add here your module params\n  args = list(), {\n    ns &lt;- session$ns\n    expect_true(\n      inherits(ns, \"function\")\n    )\n    expect_true(\n      grepl(id, ns(\"\"))\n    )\n    expect_true(\n      grepl(\"test\", ns(\"test\"))\n    )\n    # Here are some examples of tests you can\n    # run on your module\n    # - Testing the setting of inputs\n    # session$setInputs(x = 1)\n    # expect_true(input$x == 1)\n    # - If ever your input updates a reactiveValues\n    # - Note that this reactiveValues must be passed\n    # - to the testServer function via args = list()\n    # expect_true(r$x == 1)\n    # - Testing output\n    # expect_true(inherits(output$tbl$html, \"html\"))\n})\n\ntest_that(\"module ui works\", {\n  ui &lt;- mod_name_ui(id = \"test\")\n  golem::expect_shinytaglist(ui)\n  # Check that formals have not been removed\n  fmls &lt;- formals(mod_name_ui)\n  for (i in c(\"id\")) {\n    expect_true(i %in% names(fmls))\n  }\n})\n\n\nexport = TRUE: exports the module functions (@export) with the name provided to name (@rdname).\n\nThe gap application includes two modules:\n_apps/gap/R\n    ├── mod_scatter_display.R\n    └── mod_var_input.R\nmod_var_input collects the reactive inputs from the UI and passes them to mod_scatter_display (view the code in these modules here on GitHub).\n\n\nUtility functions\nThe scatter_plot() utility function was created with the utils argument of add_module(), so it’s stored the mod_scatter_display_utils.R file:\n\nscatter_plot &lt;- function(df, x_var, y_var, col_var, alpha_var, size_var) {\n    ggplot2::ggplot(data = df,\n      ggplot2::aes(x = .data[[x_var]],\n          y = .data[[y_var]],\n          color = .data[[col_var]])) +\n      ggplot2::geom_point(alpha = alpha_var, size = size_var)\n\n}\n\nUtility functions can also be created directly with golem::add_utils() or golem::add_fct().3\n\n\n\n\n\n\nCode file names\n\n\n\n\n\n\nIncluding mod in the name of module scripts and functions makes it easier to separate them from other functions in my package namespace, if I’m using tab-completion, or if I’m searching for a particular file using Ctrl + .:\n\n\n\n\n\n\n\nFigure 2: Go to File/Function in RStudio\n\n\n\n\n\n\n\n\nData\n\nmovies.RData was added to inst/extdata and loaded into the package with usethis::use_data_raw()\n\n\n\n\n\n\n\nAdding data to a package\n\n\n\n\n\n\nAfter calling usethis::use_data_raw('movies'), I can use system.file() to locate the external data file with the following code in data-raw/movies.R:\n## code to prepare `movies` dataset goes here\npth &lt;- system.file('extdata/movies.RData', package = 'gap')\nload(pth)\nusethis::use_data(movies, overwrite = TRUE)\nThis keeps the original data (extdata/movies.RData) separate from the package data (data/movies.rda).\n\n\n\n\n\n\nUnit tests\ngolem apps come with boilerplate unit tests via use_recommended_tests(), use_utils_ui(with_test = TRUE), use_utils_server(with_test = TRUE).\n\ntests/testthat/\n            ├── test-golem-recommended.R\n            ├── test-golem_utils_server.R\n            └── test-golem_utils_ui.R\n\n2 directories, 3 files\n\nDuring development, we can include unit tests for new modules and/or functions using the with_test = TRUE argument.\n\n\nSystem tests\nSystem tests can be performed with shinytest2 (similar to non-package or non-golem apps). Two example shinytest2 tests can be found in test-shinytest2.R and test-app-feature-01.R:\n\ntests\n└── testthat\n    ├── fixtures\n    │   ├── make-tidy_ggp2_movies.R\n    │   └── tidy_ggp2_movies.rds\n    ├── helper.R\n    ├── setup-shinytest2.R\n    ├── test-app-feature-01.R\n    └── test-shinytest2.R\n\n\ntest-shinytest2.R contains the boilerplate test from running shinytest2::record_test():\n\n\nshow/hide test-shinytest2.R\nlibrary(shinytest2)\ntest_that(\"{shinytest2} recording: feature-01\", {\n  app &lt;- AppDriver$new(name = \"feature-01\", height = 800, width = 1173)\n  app$set_inputs(`vars-y` = \"imdb_num_votes\")\n  app$set_inputs(`vars-x` = \"critics_score\")\n  app$set_inputs(`vars-z` = \"genre\")\n  app$set_inputs(`vars-alpha` = 0.7)\n  app$set_inputs(`vars-size` = 3)\n  app$set_inputs(`vars-plot_title` = \"New plot title\")\n  app$expect_values()\n})\n\n\ntest-app-feature-01.R contains testthats BDD functions describing an app feature and scenario:\n\n\nshow/hide test-app-feature-01.R\nlibrary(shinytest2)\ndescribe(\"Feature 1: Scatter plot data visualization dropdowns\n           As a film data analyst\n           I want to explore variables in the movie review data\n           So that I can analyze relationships between movie reivew sources\", {\n\n  describe(\"Scenario A: Change dropdown values for plotting\n             Given the movie review application is loaded\n             When I choose the variable [critics_score] for the x-axis\n             And I choose the variable [imdb_num_votes] for the y-axis\n             And I choose the variable [genre] for the color\", {\n        it(\"Then the scatter plot should show [critics_score] on the x-axis\n             And the scatter plot should show [imdb_num_votes] on the y-axis\n             And the points on the scatter plot should be colored by [genre]\", {\n              app &lt;- AppDriver$new(name = \"feature-01-senario-a\",\n                                     height = 800, width = 1173)\n                app$set_inputs(`vars-y` = \"imdb_num_votes\")\n                app$set_inputs(`vars-x` = \"critics_score\")\n                app$set_inputs(`vars-z` = \"genre\")\n                app$expect_values()\n       })\n   })\n\n  describe(\"Scenario B: Change dropdown values for plotting\n              Given the movie review application is loaded\n              When I choose the size of the points to be [3]\n              And I choose the opacity of the points to be [0.7]\n              And I enter '[New plot title]' for the plot title\", {\n         it(\"Then the size of the points on the scatter plot should be [3]\n              And the opacity of the points on the scatter plot should be [0.7]\n              And the title of the plot should be '[New plot title]'\", {\n              app &lt;- AppDriver$new(name = \"feature-01-senario-b\",\n                                     height = 800, width = 1173)\n                app$set_inputs(`vars-alpha` = 0.7)\n                app$set_inputs(`vars-size` = 3)\n                app$set_inputs(`vars-plot_title` = \"New plot title\")\n                app$expect_values()\n        })\n    })\n})\n\n\n\n\n\nTest coverage\nThe covrpage package provides a test coverage report in tests/README.md file. This file includes a report of the R file tested, the unit test context, number of tests, and the test status.4\n\n\nAdding files and images\nTo include other files (like images), add the image file to inst/app/www/, then add the www/ to the path (see example UI code below)\n\n# add icon\nshiny::tags$img(src = \"www/shiny.png\")\n\nIf I wanted to include images in their own folder (like images/), I can use golem::addResourcePath() to add the name of the sub-folder to inst/app/\n\n# add icon\ngolem::add_resource_path(\n          prefix = 'images', \n          directoryPath = system.file('app/images', \n                                      package = 'gap'))\n\nNow I can add the image file to the inst/app/www/images/ folder and include the following code in the UI:\n\n# add icon\nshiny::tags$img(src = \"www/images/golem-hex.png\")\n\nIn R/app_ui.R, the app_ui() function contains the UI layout functions (fluidPage(), sidebarLayout(), etc.), and a call to golem_add_external_resources():\n\n#' The application User-Interface\n#'\n#' @param request Internal parameter for `{shiny}`.\n#'     DO NOT REMOVE.\n#' @import shiny\n#' @noRd\napp_ui &lt;- function(request) {\n  tagList(\n    # Leave this function for adding external resources\n    golem_add_external_resources(),\n    # Your application UI logic\n    fluidPage(\n      sidebarLayout(\n        sidebarPanel(\n          mod_var_ui(\"vars\"),\n          h6(\n            img(src = \"www/images/shiny.png\", width = \"15%\"),\n            em(\n              \"The data for this application comes from the \",\n              a(\"Building web applications with Shiny\",\n                href = \"https://rstudio-education.github.io/shiny-course/\"\n              ),\n              \"tutorial\"\n            )\n          )\n        ),\n        mainPanel(\n          fluidRow(\n            br(),\n            p(em(\"Brought to you by: \"),\n              # add golem hex (in www/images/)\n              img(src = \"www/images/golem-hex.png\", width = \"5%\")\n            )\n          ),\n          mod_plot_ui(\"plot\")\n        )\n      )\n    )\n  )\n}\n\nAfter running devtools::load_all(), devtools::document(), devtools::install(), the image is properly rendered with the application:\n\n\n\n\n\n(a) gap::run_app()\n\n\nFigure 3: Images in gap\n\n\n\n\n\n\n\n\nUsing the inst/ folder\n\n\n\n\n\n\ngolem takes advantage of the inst/ folder and R package structure to allow users to provide additional ‘assets’ to the application.\nFor example, if we use system.file() on the local directory ('.'), we see all the folders available to the application at runtime\nfs::dir_tree(path = system.file('', package = 'gap'))\n/Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/library/gap/.\n├── DESCRIPTION\n├── INDEX\n├── LICENSE\n├── Meta\n│   ├── Rd.rds\n│   ├── data.rds\n│   ├── features.rds\n│   ├── hsearch.rds\n│   ├── links.rds\n│   ├── nsInfo.rds\n│   └── package.rds\n├── NAMESPACE\n├── R\n│   ├── gap\n│   ├── gap.rdb\n│   └── gap.rdx\n├── WORDLIST\n├── app\n│   └── www\n│       ├── favicon.ico\n│       └── images\n│           ├── golem-hex.png\n│           └── shiny.png\n├── data\n│   ├── Rdata.rdb\n│   ├── Rdata.rds\n│   └── Rdata.rdx\n├── extdata\n│   └── movies.RData\n├── golem-config.yml\n├── help\n│   ├── AnIndex\n│   ├── aliases.rds\n│   ├── gap.rdb\n│   ├── gap.rdx\n│   └── paths.rds\n└── html\n    ├── 00Index.html\n    └── R.css\n\n\n\n\n\n\nAdding resources\ngolem has multiple functions for creating and using external files in your Shiny app-package. The add_dockerfile* set of functions are particularly helpful for including Docker files. I’ll cover two here: golem::add_dockerfile() and golem::add_dockerfile_with_renv().\nIn the gap directory, you’ll see the Dockerfile from add_dockerfile(). The files from add_dockerfile_with_renv() are in the inst/docker-renv folder..\n\nadd_dockerfile\nadd_dockerfile() results in the following Dockerfile:\n\nFROM rocker/verse:4.3.2\nRUN apt-get update && apt-get install -y  libicu-dev libxml2-dev make pandoc zlib1g-dev && rm -rf /var/lib/apt/lists/*\nRUN mkdir -p /usr/local/lib/R/etc/ /usr/lib/R/etc/\nRUN echo \"options(repos = c(CRAN = 'https://cran.rstudio.com/'), download.file.method = 'libcurl', Ncpus = 4)\" | tee /usr/local/lib/R/etc/Rprofile.site | tee /usr/lib/R/etc/Rprofile.site\nRUN R -e 'install.packages(\"remotes\")'\nRUN Rscript -e 'remotes::install_version(\"rlang\",upgrade=\"never\", version = \"1.1.2\")'\nRUN Rscript -e 'remotes::install_version(\"knitr\",upgrade=\"never\", version = \"1.45\")'\nRUN Rscript -e 'remotes::install_version(\"stringr\",upgrade=\"never\", version = \"1.5.1\")'\nRUN Rscript -e 'remotes::install_version(\"shiny\",upgrade=\"never\", version = \"1.8.0\")'\nRUN Rscript -e 'remotes::install_version(\"config\",upgrade=\"never\", version = \"0.3.2\")'\nRUN Rscript -e 'remotes::install_version(\"spelling\",upgrade=\"never\", version = \"2.2.1\")'\nRUN Rscript -e 'remotes::install_version(\"rmarkdown\",upgrade=\"never\", version = \"2.25\")'\nRUN Rscript -e 'remotes::install_version(\"golem\",upgrade=\"never\", version = \"0.4.1\")'\nRUN Rscript -e 'remotes::install_version(\"ggplot2\",upgrade=\"never\", version = \"3.4.4\")'\nRUN Rscript -e 'remotes::install_github(\"rstudio/htmltools@a8a3559edbfd9dda78418251e69273fa9dfeb9bc\")'\nRUN Rscript -e 'remotes::install_github(\"r-lib/testthat@fe50a222c62cc8733b397690caf3b2a95856f902\")'\nRUN mkdir /build_zone\nADD . /build_zone\nWORKDIR /build_zone\nRUN R -e 'remotes::install_local(upgrade=\"never\")'\nRUN rm -rf /build_zone\nEXPOSE 80\nCMD R -e \"options('shiny.port'=80,shiny.host='0.0.0.0');library(gap);gap::run_app()\"\n\nThis Dockerfile sets up a Docker image with specific R/Linux packages, adds and installs the gap app-package from the current directory, and configures the container to run the Shiny app on port 80.\n\nFROM rocker/verse:4.3.2 which is a pre-built R environment.\nRUN apt-get update && apt-get install -y updates and installs several Linux packages:\n\nlibcurl4-openssl-dev: These are the development files and libraries for libcurl, which is used for for secure data transfer operations in R packages (the openssl indicates OpenSSL support).\nlibicu-dev: The development files and libraries for the International Components for Unicode library.\nlibssl-dev: The development files and libraries for SSL libraries, necessary for secure communications over networks.\nlibxml2-dev: Development files for the libxml2 library, which is used for parsing XML and HTML documents.\nmake: the make build utility that automatically builds executable programs and libraries from source code.\npandoc: the universal document converter used for converting markdown files to various other formats\nzlib1g-dev: development files for the zlib compression library\nrm -rf /var/lib/apt/lists/* cleans up the package list to reduce the image size.\n\nRUN mkdir -p /usr/local/lib/R/etc/ /usr/lib/R/etc/ creates two directories (/usr/local/lib/R/etc/ and /usr/lib/R/etc/) for R configuration files\nRUN echo \"options(...) | tee ... configures global R settings (CRAN repository, download method, and number of CPU cores)\nRUN R -e 'install.packages(\"remotes\")' installs the remotes package\nRUN Rscript -e 'remotes::install_version(...)' is used to installs specific versions of R packages used in the gap app-package without upgrading dependencies.\nRUN Rscript -e 'remotes::install_github(...)' is used to install R packages directly from GitHub repositories (at specific commits).\nRUN mkdir /build_zone will create a directory in the image for building the application.\nADD . /build_zone adds the contents of the current directory (from where the Docker build command is run) into the /build_zone directory in the image.\nWORKDIR /build_zone sets the /build_zone directory as the working directory for all subsequent commands.\nRUN R -e 'remotes::install_local(upgrade=\"never\")' installs the R package located in /build_zone without upgrading dependencies (this is our gap app-package being containerized).\nRUN rm -rf /build_zone reduce the final image size by removing the /build_zone directory.\nEXPOSE 80` exposes port 80 of the container (this is typically used for web applications like Shiny apps).\nCMD R -e \"options('shiny.port'=80,shiny.host='0.0.0.0');library(gap);gap::run_app()\" specifies the command to be run when the Docker container starts. These calls set the port and host Shiny app options, loads gap, and runs the standalone app function (gap::run_app()).\n\n\n\nadd_dockerfile_with_renv\nadd_dockerfile_with_renv() creates a tmp/deploy folder and adds the following files:\n\ndeploy/\n  ├── Dockerfile\n  ├── Dockerfile_base\n  ├── README\n  ├── gap_0.0.0.9000.tar.gz\n  └── renv.lock.prod\n\n\nDockerfile_base is used to create a base image with necessary dependencies and configurations\n\nFROM rocker/verse:4.3.2\nRUN apt-get update -y && apt-get install -y  make zlib1g-dev git libicu-dev && rm -rf /var/lib/apt/lists/*\nRUN mkdir -p /usr/local/lib/R/etc/ /usr/lib/R/etc/\nRUN echo \"options(renv.config.pak.enabled = FALSE, repos = c(CRAN = 'https://cran.rstudio.com/'), download.file.method = 'libcurl', Ncpus = 4)\" | tee /usr/local/lib/R/etc/Rprofile.site | tee /usr/lib/R/etc/Rprofile.site\nRUN R -e 'install.packages(\"remotes\")'\nRUN R -e 'remotes::install_version(\"renv\", version = \"1.0.3\")'\nCOPY renv.lock.prod renv.lock\nRUN R -e 'renv::restore()'\n\n\nEach instruction does the following:\n\nRUN apt-get update -y && apt-get install updates and installs several Linux packages (make, zlib1g-dev, git, libicu-dev)\nRUN mkdir and RUN echo creates directories and configures R settings (CRAN repository, download method, number of CPUs to use)\nRUN R -e installs the remotes package and version 1.0.3 of the renv package (renv is used for project-local package management)\nCOPY copies a file renv.lock.prod into the image as renv.lock\nRUN R -e uses renv::restore() to install the R packages specified in this lock file\n\n\nDockerfile builds on this base image to set up the gap app-package and its dependencies.\n\nFROM gap_base\nCOPY renv.lock.prod renv.lock\nRUN R -e 'renv::restore()'\nCOPY gap_*.tar.gz /app.tar.gz\nRUN R -e 'remotes::install_local(\"/app.tar.gz\",upgrade=\"never\")'\nRUN rm /app.tar.gz\nEXPOSE 80\nCMD R -e \"options('shiny.port'=80,shiny.host='0.0.0.0');library(gap);gap::run_app()\"\n\n\nThese instructions perform the following:\n\nFROM gap_base starts from gap_base, which is the image built using Dockerfile_base.\nCOPY & RUN R -e repeats the step of copying renv.lock.prod and restoring packages using renv::restore().\nCOPY gap_*.tar.gz /app.tar.gz copies files matching gap_*.tar.gz (presumably our compressed app-package) into the image as /app.tar.gz.\nRUN R -e installs this local package using remotes::install_local().\nRUN rm reduce the size of the final image by removing the copied tar.gz file.\nEXPOSE 80 exposes port 80 (necessary for external access to the app when it’s running inside the container).\nCMD R -e defines the command to run when the container starts, which in this case, runs the gap application (gap::run_app()) on port 80 and (bound to 0.0.0.0).\n\n\nThe docker build and docker run commands in the README create the base image from Dockerfile_base, start the container from the Dockerfile image, and launche the gap application on port 80.\n\ndocker build -f Dockerfile_base --progress=plain -t gap_base .\ndocker build -f Dockerfile --progress=plain -t gap:latest .\ndocker run -p 80:80 gap:latest\n# then go to 127.0.0.1:80\n\ngap_0.0.0.9000.tar.gz is the app-package to deploy in the Docker container."
  },
  {
    "objectID": "golem.html#dependencies",
    "href": "golem.html#dependencies",
    "title": "The golem framework",
    "section": "Dependencies",
    "text": "Dependencies\nBelow is a quick overview of the dependencies in gap.\n\nNAMESPACE\nThe namespace file for gap is importing shiny (and the .data operator from rlang).\n# Generated by roxygen2: do not edit by hand\n\nexport(run_app)\nimport(shiny)\nimportFrom(rlang,.data)\nAs you can see, we’re only exporting the run_app() function from gap.\n\n\nImports\nThe Imports field in the DESCRIPTION file lists the following:\nImports: \n    config (&gt;= 0.3.1),\n    ggplot2,\n    golem (&gt;= 0.3.5),\n    rlang,\n    shiny (&gt;= 1.7.4),\n    stringr,\n    tools\nAs we can see, golem apps add golem as a dependency:\n\npak::local_deps_explain(\n  deps = 'golem', \n  root = \"_apps/gap\")\nℹ Loading metadata database\n✔ Loading metadata database ... done\n\ngap -&gt; golem"
  },
  {
    "objectID": "golem.html#recap",
    "href": "golem.html#recap",
    "title": "The golem framework",
    "section": "Recap",
    "text": "Recap\nIf you typically build Shiny apps in a single app.R file (or in ui.R and server.R files), the golem framework might seem overwhelming. I’ll give a quick overview of some areas I found confusing when I started using goelm:\n\ndev/ contains golem‘s ’guided tour’ scripts (01_start.R, 02_dev.R, 03_deploy.R) and run_dev.R\nR/: the primary app files for the UI and server are stored in the R/ folder (R/app_ui.R, R/app_server.R, R/run_app.R), as well as the configuration function (R/app_config.R)\ngolem apps are run using the gap::run_app() function (included in the R/ folder)\nWhile developing, golem also comes with a run_dev function that reads the R/run_dev.R file and evaluates the code.\nThe inst/ folder holds the golem-config.yml and location of any external app files.\nDeploying the application can be done with a single function: rsconnect::deployApp()\n\nGenerally speaking, golem’s start-up scripts save time and serve as a gentle introduction to some of the functions used in R package development.\nThe add_ functions are an area where golem really separates itself from standard R package development. Having dedicated Shiny development functions (and the app/inst/www folder) reduces the cognitive overhead of mapping the standard R package development functions (i.e., those from usethis and devtools) into Shiny app-package development.\ngolem is a popular framework for a reason–it’s designed to allow developers to build a shiny application and R package simultaneously. Added bonuses include taking advantage of RStudio’s build tools, great documentation, and user-guides..\nBelow is an overview of the features/functions in the golem framework:\n\n\n\n\nFeature\nArguments/Options\nDescription/Comments\n\n\n\n\ndev/ scripts\n\ndev/01_start.R\ndev/02_dev.R\ndev/03_deploy.R\n\nThese files are automatically included in new golem apps and walk through set up, development, and deployment\n\n\nfill_desc(): fills DESCRIPTION file\nArguments are passed as strings without having to worry about formatting (i.e., utils::person()).\nIncludes many necessary fields often overlooked when using usethis::create_package()\n\n\nattachment::att_amend_desc()\nUpdates the package dependencies in the Imports field of DESCRIPTION\nAlthough not part of the golem package, attachment is built by the fine folks at ThinkR and makes managing dependencies smoother.\n\n\nset_golem_options()\n\nThis sets a variety of options in the golem-config.yml file (most notably the name, version, and path to your app-package).\n\n\nuse_recommended_tests()\n\nCreate testthat infrastructure and adds a collection of boilerplate tests in the tests/testthat/ folder.\n\n\nuse_utils_ui() & use_utils_server()\nwith_test is set to TRUE\nCreates a collection of commonly used UI and server functions (and accompanying tests).\n\n\nadd_module(\"name\", fct, utils, export, with_test)\nname: ‘name’ creates mod_name_ui() and mod_name_server()\nfct: creates R/mod_name_fct.R\nutils: R/mod_name_utils.R\nexport: adds @export\nwith_test: creates tests/testthat/test-mod_name.R and includes boilerplate tests.\nThis is one of the best features in golem . A single function will create two module functions (and a module file), utility functions, and accompanying tests.\nAn added bonus is a consistent file naming convention.\n\n\nadd_fct() and add_utils()\nwith_test: creates the accompanying tests/testthat/test-[name].R file.\nThese are essentially wrappers for usethis::use_r() and usethis::use_test()\n\n\nAdding non-R code files:\n\nadd_js_file(\"script\")\nadd_js_handler(\"handlers\")\nadd_css_file(\"custom\")\nadd_sass_file(\"custom\")\n\nEach add_ function has a template:\njs_template()\njs_hanler_template()\ncss_template()\nsass_template()\nEach of these functions create the necessary files in the inst/app folder."
  },
  {
    "objectID": "golem.html#footnotes",
    "href": "golem.html#footnotes",
    "title": "The golem framework",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThe code used to build the golem app is here.↩︎\nThe tests golem creates in the tests/testthat/ folder can serve as a nice guide for users new to testthat↩︎\nNew functions created with golem::add_*() functions are placed in the R/ folder with a @noRd tag by default (this behavior can be changed with the export argument).↩︎\nTest coverage is only included for the three initial golem test files (test-golem-recommended.R, test-golem_utils_server.R, test-golem_utils_ui.R).↩︎"
  },
  {
    "objectID": "rhino.html",
    "href": "rhino.html",
    "title": "the rhino framework",
    "section": "",
    "text": "rhino apps are unique because unlike golem and leprechaun, they aren’t R packages. rhino uses box modules to manage add-on package functions, which minimizes dependencies and separates the application’s code into a clear ‘division of labor.’1"
  },
  {
    "objectID": "rhino.html#getting-started",
    "href": "rhino.html#getting-started",
    "title": "the rhino framework",
    "section": "Getting started",
    "text": "Getting started\nTo create a new rhino application, select Project &gt; New Project &gt; New Directory, and Shiny Application using rhino. The New Project Wizard will require a Directory name and subdirectory and Github Actions CI (selected by default)\n\n\n\n\n\n(a) New Project Wizard\n\n\nFigure 1: New rhino app\n\n\nAfter clicking Create Project, you’ll see the following output in the **Console*:**\n\nThe following package(s) will be updated in the lockfile:\n\n# CRAN ------------------------------------------------------\n- renv           [* -&gt; 1.0.3]\n\n# GitHub ----------------------------------------------------\n- testthat       [* -&gt; r-lib/testthat@HEAD]\n\n# RSPM ------------------------------------------------------\n  \n      &lt; &lt; &lt; &lt; &lt; &lt; &lt; OMITTED &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt;\n  \nThe version of R recorded in the lockfile will be updated:\n- R              [* -&gt; 4.3.1]\n\n- Lockfile written to \"~/projects/pkgs/rap/renv.lock\".\n- Project '~/projects/pkgs/rap' loaded. [renv 1.0.3]\n✔ Initialized renv.\n✔ Application structure created.\n✔ Unit tests structure created.\n✔ E2E tests structure created.\n✔ Github Actions CI added.\n\nThis initializes the new rhino app by opening the .Rproj file in RStudio. To create a rhino application from the console, use the following:\n\ninstall.packages(\"rhino\")\nrhino::init(\"/path/to/rhino/app\")"
  },
  {
    "objectID": "rhino.html#rhino-structure",
    "href": "rhino.html#rhino-structure",
    "title": "the rhino framework",
    "section": "rhino structure",
    "text": "rhino structure\nThe initial folder structure for a new rhino app is below:\n\nrap/\n├── app\n│   ├── js\n│   ├── logic\n│   ├── main.R\n│   ├── static\n│   ├── styles\n│   └── view\n├── app.R\n├── brap.Rproj\n├── config.yml\n├── dependencies.R\n├── renv\n│   ├── activate.R\n│   ├── library\n│   └── settings.json\n├── renv.lock\n├── rhino.yml\n└── tests\n    ├── cypress\n    ├── cypress.json\n    └── testthat\n\n12 directories, 10 files\n\nThe rhino package website has excellent documentation on their app structure philosophy, and it’s worth reading through this before getting started. I’ll do my best to summarize the application’s files below:\n\nApp code\nThe app/ folder contains the primary folder and files:\n\napp/\n  ├── js/\n  ├── logic/\n  ├── main.R\n  ├── static/\n  ├── styles/\n  └── view/\n\n6 directories, 1 file\n\nThe subfolders in app/ contain the following files:\n\napp/js/: initially contains a blank index.js script\napp/logic/: contains utility functions and code independent from Shiny\napp/static/: stores external resources (like JavaScript files) and is similar to the sub-folders in inst/ from golem and leprechaun\napp/styles/: holds custom styles (CSS and HTML) in the app/styles/main.css file (which is initially blank)\napp/view/: will hold all the code used to build the application and relies upon the reactive capabilities of Shiny.\napp/main.R: contains the primary ui and server code (similar to app_ui and app_server in a golem application)\n\nThe initial main.R file contains the following code:\n\n\n\nshow/hide initial app/main.R\nbox::use(\n  shiny[bootstrapPage, moduleServer, NS, renderText, tags, textOutput],\n)\n\n#' @export\nui &lt;- function(id) {\n  ns &lt;- NS(id)\n  bootstrapPage(\n    tags$h3(\n      textOutput(ns(\"message\"))\n    )\n  )\n}\n\n#' @export\nserver &lt;- function(id) {\n  moduleServer(id, function(input, output, session) {\n    output$message &lt;- renderText(\"Hello!\")\n  })\n}\n\n\n\n\n\n\n\n\n\n\nbox::use()?\n\n\n\n\n\n\nIf the box syntax looks strange–don’t worry! box is designed to ‘completely replaces the base R library and require functions.’ We’ll cover it more in the Build section below.\n\n\n\n\n\n\napp.R\n\napp.R will run the application and contains the rhino::app() function:2\n\n\n# Rhino / shinyApp entrypoint. Do not edit.\nrhino::app()\n\n\n\nYAML files\nNew rhino apps begin with two .yml configuration files:\n\nconfig.yml is a YAML file that follows the config package format.\n\nThis file initially contains two calls to rhinos environment variables:3\n\ndefault:\n  rhino_log_level: !expr Sys.getenv(\"RHINO_LOG_LEVEL\", \"INFO\")\n  rhino_log_file: !expr Sys.getenv(\"RHINO_LOG_FILE\", NA)\n\n\nrhino.yml is a configuration file that contains options for 1) Sass build settings, and 3) import a legacy application structure to rhino.4\n\nthe code below showcases the optional arguments (and is not included in the application)\n\nsass: string               # required | one of: \"node\", \"r\"\nlegacy_entrypoint: string  # optional | one of: \"app_dir\", \"source\", \"box_top_level\"\n\n\n\nDependencies\nrhino apps manage dependencies with the dependencies.R file and renv package.\n\ndependencies.R contains any add-on packages used in the application. As we can see from the note in the comments, dependencies are tracked using packrat in rsconnect.5\n\n# This file allows packrat (used by rsconnect during deployment)\n# to pick up dependencies.\nlibrary(rhino)\n\n\n\nThe renv/ folder stores the R package versions used in the application. renv.lock contains the packages and R version used in our application.6\n\nrap/\n  ├── renv/\n  │    ├── activate.R\n  │    ├── library/\n  │    ├── sandbox/\n  │    └── settings.dcf\n  └── renv.lock\n\n\nWe know we’ll be using ggplot2, stringr, and rlang in the app, so we’ll load these packages here:\n\n\nrhino::pkg_install(c(\"ggplot2\", \"stringr\", \"rlang\"))\n\n\nAdding packages with rhino::pkg_install() will automatically update dependencies.R and renv\n\n\n\n\nTests\nThe tests/ folder initially contains two sub-folders, cypress/ and testthat/, and the cypress.json file.\n\ntests/\n    ├── cypress/\n    ├── cypress.json\n    └── testthat/\n\n\ntests/cypress/ holds folders for using the Cypress web and component testing framework.7\ntests/\n    ├── cypress/\n    │    └── integration/\n    │        └── app.spec.js\n    └── cypress.json\n\n\ntests/testthat/ contains the architecture for writing unit tests with testthat, which can be run with the rhino::test_r() helper function:8\ntests/\n    └── testthat/\n            └── test-main.R"
  },
  {
    "objectID": "rhino.html#building-a-rhino-app",
    "href": "rhino.html#building-a-rhino-app",
    "title": "the rhino framework",
    "section": "Building a rhino app",
    "text": "Building a rhino app\nNow that we’ve covered the initial file and folder structure of a new rhino application, we’re going to cover how to convert the ‘vanilla’ Shiny app below into the rhino structure. We’ll have to 1) load the movies data, and 2) create/call the scatter_plot() utility function, and 3) convert the contents of app.R into modules.\n\n\nshow/hide monolithlic app.R file\nui &lt;- shiny::fluidPage(\n  theme = shinythemes::shinytheme(\"spacelab\"),\n  shiny::sidebarLayout(\n    shiny::sidebarPanel(\n      shiny::selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n\n      shiny::selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n\n      shiny::selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n\n      shiny::sliderInput(\n        inputId = \"alpha\",\n        label = \"Alpha:\",\n        min = 0, max = 1,\n        value = 0.4\n      ),\n\n      shiny::sliderInput(\n        inputId = \"size\",\n        label = \"Size:\",\n        min = 0, max = 5,\n        value = 3\n      ),\n\n      shiny::textInput(\n        inputId = \"plot_title\",\n        label = \"Plot title\",\n        placeholder = \"Enter text to be used as plot title\"\n      ),\n\n      shiny::actionButton(\n        inputId = \"update_plot_title\",\n        label = \"Update plot title\"\n      )\n    ),\n\n    shiny::mainPanel(\n      shiny::br(),\n      shiny::p(\n        \"These data were obtained from\",\n        shiny::a(\"IMBD\", href = \"http://www.imbd.com/\"), \"and\",\n        shiny::a(\"Rotten Tomatoes\", href = \"https://www.rottentomatoes.com/\"), \".\"\n      ),\n      shiny::p(\"The data represent\", \n        nrow(movies), \n        \"randomly sampled movies released between 1972 to 2014 in the United States.\"),\n      shiny::plotOutput(outputId = \"scatterplot\"),\n      shiny::hr(),\n        shiny::p(shiny::em(\"The code for this shiny application comes from\", \n          shiny::a(\"Building Web Applications with shiny\", \n            href = \"https://rstudio-education.github.io/shiny-course/\"))\n          )\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  \n  new_plot_title &lt;- shiny::reactive({\n      tools::toTitleCase(input$plot_title)\n    }) |&gt; \n    shiny::bindEvent(input$update_plot_title, \n                     ignoreNULL = FALSE, \n                     ignoreInit = FALSE)\n    \n\n  output$scatterplot &lt;- shiny::renderPlot({\n    scatter_plot(\n        df = movies,\n        x_var = input$x,\n        y_var = input$y,\n        col_var = input$z,\n        alpha_var = input$alpha,\n        size_var = input$size\n      ) + \n      ggplot2::labs(title = new_plot_title()) + \n      ggplot2::theme_minimal() +\n      ggplot2::theme(legend.position = \"bottom\")\n  })\n}\n\nshiny::shinyApp(ui = ui, server = server)\n\n\n\n\nshow/hide scatter_plot.R utility function\nscatter_plot &lt;- function(df, x_var, y_var, col_var, alpha_var, size_var) {\n    ggplot2::ggplot(data = df,\n      ggplot2::aes(x = .data[[x_var]],\n          y = .data[[y_var]],\n          color = .data[[col_var]])) +\n      ggplot2::geom_point(alpha = alpha_var, size = size_var)\n\n}\n\n\nDownload the movies dataset.\n\nbox modules\n\n\n\n\n\n\n\n\n\n\n\nUnlike R packages, rhino applications don’t use the NAMESPACE and DESCRIPTION to manage dependencies. Instead, they use the box modules to explicitly import packages and functions. box is designed for writing “reusable, composable and modular R code”\n\nDependency refresher\nIn standard Shiny app development, add-on package functions are used with the following steps:\n\ninstall the package using install.packages('pkg')\nrun library(pkg), which loads the package namespace ‘and attach[es] it on the search list’\n\nIf/when the app is converted into an R package, add-on packages are managed by:\n\nincluding the package in the DESCRIPTION file\nusing pkg::fun() in code below R/ 9\n\nThe methods above might prompt the following questions:\n\nWhy do we load and attach the entire package namespace and if we only need a single function during standard (i.e., non-package) R development? 10\nWhy do we install the entire package in the DESCRIPTION if we’re only accessing a single function below R with pkg::fun() in our R package? 11\n\nThis is where box comes in–it’s designed to ‘completely replace the base R library and require functions’.\n\n\nHow box modules work\nBelow is a quick demonstration of box modules using tidyverse::tidyverse_logo(). If we attempted to use the tidyverse_logo() function without installing or loading the tidyverse meta-package, we see the following error:12\n\ntidyverse_logo()\n\nError in tidyverse_logo(): could not find function \"tidyverse_logo\"\nThis is expected, because even if tidyverse has been installed, it hasn’t been loaded with libaray(tidyverse). box modules allow us to encapsulate and explicitly import packages and functions.13\nBelow is a quick demonstration of how they work:\n\n\n\n\n\n1) Create folder\nCreate a new box module named tidy (which again, is just a folder named tidy)\n\n\n2) Import\nImport the tidyverse_logo() from tidyverse by creating a logo.R file with the following code\n\n\n3) Use module\nCall box::use(tidy/logo) to access the logo object from the tidy module\n\n\n\n\n\n\n└──tidy/\n    └─logo.R \n\n\n#' @export\nbox::use(\n  tidyverse[tidyverse_logo]\n)\n\n\nbox::use(\n  tidy/logo\n)\n\n\n\nbox::use() creates and accesses box modules. The first call to box::use() in tidy/logo.R places tidyverse_logo() in a tidy module, and the second call to box::use() allows us to use the logo object.\n\nUse ls() on logo to return the object(s) it imports:\n\nls(logo)\n\n[1] \"tidyverse_logo\"\n\nTo access the objects within a box module, use the $ operator.\n\nlogo$tidyverse_logo()\n\n⬢ __  _    __   .    ⬡           ⬢  . \n / /_(_)__/ /_ ___  _____ _______ ___ \n/ __/ / _  / // / |/ / -_) __(_-&lt;/ -_)\n\\__/_/\\_,_/\\_, /|___/\\__/_/ /___/\\__/ \n     ⬢  . /___/      ⬡      .       ⬢ \n\nbox modules are self-contained, meaning the tidyverse_logo() function only exists inside the logo module. Explicitly listing the packages and functions we intend to use with box::use() means we no longer need to include calls to install.packages() and library() or require().\n\nNote what happens when I try to access the tidyverse_logo() function by itself:\n\ntidyverse_logo()\n\nError in tidyverse_logo(): could not find function \"tidyverse_logo\"\n\n\nThis was a very brief overview of box, so I highly recommend consulting the box website and vignettes. The rhino website also has a great overview on using box with Shiny apps.14"
  },
  {
    "objectID": "rhino.html#data",
    "href": "rhino.html#data",
    "title": "the rhino framework",
    "section": "Data",
    "text": "Data\nNon-Shiny code and functions should be stored in app/logic/. We’ll include a box module for importing the movies data in app/logic/data.R.15\n\n# contents of app/logic/data.R\n\n#' @export\nbox::use(\n1  vroom[vroom, cols, col_skip]\n)\n\n#' import movies data \n#' @export\nmovies_data &lt;- function() {\n  raw_csv_url &lt;- \"https://bit.ly/47FPO6t\"\n  # from 07_data branch!\n2  vroom(raw_csv_url,\n    col_types = cols(...1 = col_skip()))\n}\n\n\n1\n\nAdd vroom functions\n\n2\n\nCall vroom functions\n\n\n\n\nIn app/logic/data.R, the necessary vroom functions are included with box::use() to import movies.csv from GitHub."
  },
  {
    "objectID": "rhino.html#utility-functions",
    "href": "rhino.html#utility-functions",
    "title": "the rhino framework",
    "section": "Utility functions",
    "text": "Utility functions\nThe scatter_plot() utility function is stored in app/logic/plot.R. Again, box::use() includes the ggplot2 and rlang functions for scatter_plot():\n\n# contents of app/logic/plot.R\n\n#' scatter plot function\n#' @export\nscatter_plot &lt;- function(df, x_var, y_var, col_var, alpha_var, size_var) {\n\nbox::use(\n1  ggplot2[ggplot, aes, geom_point],\n2  rlang[.data]\n)\n  \n3  ggplot(\n    data = df,\n    aes( \n4      x = .data[[x_var]],\n      y = .data[[y_var]],\n      color = .data[[col_var]]\n    )\n  ) +\n    geom_point(alpha = alpha_var, size = size_var)\n  \n}\n\n\n1\n\nAdd ggplot2 functions\n\n2\n\nAdd rlang functions\n\n3\n\nUse ggplot2 functions\n\n4\n\nUse rlang functions\n\n\n\n\nThe app/logic/__init__.R file exports the two modules above:16\n\n# Logic: application code independent from Shiny.\n# https://go.appsilon.com/rhino-project-structure\n#' @export\nbox::use(\n  app / logic / data,\n  app / logic / plot\n)\n\n\nUnit tests\nThe unit tests for the box modules in app/logic/ and app/view/ are in the tests/testthat/ folder:\n\ntests/testthat/\n        ├── test-data.R\n        ├── test-display.R\n        ├── test-inputs.R\n        └── test-plot.R\n\n1 directory, 4 files\n\nUnit tests with rhino applications are similar to unit tests in R packages, with a few important differences:\n\nWe don’t have access to the usethis and devtools functions for creating and running test files\n\nWe’ll need to import the necessary testthat functions with box::use()\n\nThe rhino::test_r() will run the unit tests in tests/testthat/\n\nThe first test for app/logic/data.R is below:\n\n# import testthat \nbox::use(\n  testthat[describe, it, expect_equal, expect_true]\n)\n\n# import data module\nbox::use(\n  app / logic / data\n)\n\ndescribe(description = \"Feature: Movies Data Dimensions Verification\n  As a data analyst,\n  I want to ensure the movies data frame has the correct dimensions\n  So that I can rely on its structure for further analysis.\", \n  code = {\n  it(description = \"Scenario: Checking the dimensions of the movies data frame\n    Given a function to import movies data\n    When I call the function to retrieve the movies data\n    Then the data frame should have 651 rows and 34 columns\n    And the data frame should be of type 'data.frame'\", \n    code = {\n    # call function to import movies data\n    movies &lt;- data$movies_data()\n    # test dimensions\n    expect_equal(\n      object = dim(movies), \n      expected = c(651L, 34L))\n    # test class\n    expect_true(object = is.data.frame(movies))\n  })\n})\n\nThe test for app/logic/plot.R is below. Note this test imports the app/logic/data and app/logic/plot modules:\n\n# import testthat and ggplot2 function\nbox::use(\n  testthat[describe, it, expect_equal, expect_true],\n  ggplot2[is.ggplot]\n)\n# import data and plot modules\nbox::use(\n  app / logic / data,\n  app / logic / plot\n)\n\n\ndescribe(\"Feature: Scatter Plot Generation Verification\n  As a data analyst,\n  I want to ensure that scatter_plot() generates a valid scatter plot\n  So that I can use it for visualizing relationships in movies data.\", \n  code = {\n  it(\"Scenario: Generating a scatter plot with specified parameters\n    Given a function to import movies data\n    And a function scatter_plot() from the plot module\n    When I call scatter_plot() with movies data\n    And specify x_var as 'critics_score'\n    And specify y_var as 'imdb_rating'\n    And specify col_var as 'mpaa_rating'\n    And set alpha_var to 2 / 3\n    And set size_var to 2\n    Then the function should return a ggplot object with a scatter plot\",\n    code = {\n    # call function to import movies data\n    movies &lt;- data$movies_data()\n    # test point plot\n    expect_true(\n      is.ggplot(\n          # call scatter_plot() from plot module\n          plot$scatter_plot(\n            df = movies,\n            x_var = 'critics_score', \n            y_var = 'imdb_rating', \n            col_var = 'mpaa_rating', \n            alpha_var = 2 / 3,\n            size_var = 2\n          )\n        )\n      )\n  })\n})"
  },
  {
    "objectID": "rhino.html#app-modules",
    "href": "rhino.html#app-modules",
    "title": "the rhino framework",
    "section": "App Modules",
    "text": "App Modules\nNow we’re going to convert contents of app.R into Shiny modules. Shiny modules should be placed in the app/view/ folder. rhino modules are still broken into ui and server functions, and box::use() is called within each function to add the necessary package[function]\n\nThe first module we’ll create is the app/view/inputs.R module for collecting the user inputs:\n\n# app/view/inputs.R\n\n# define module functions\n\n#' input values ui\n#' @export\nui &lt;- function(id) {\n  box::use(\n    shiny[\n      NS, tagList, selectInput, h3,\n      sliderInput, textInput\n    ],\n  )\n  ns &lt;- NS(id)\n  tagList(\n    selectInput(\n      inputId = ns(\"y\"),\n      label = \"Y-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"audience_score\"\n    ),\n    selectInput(\n      inputId = ns(\"x\"),\n      label = \"X-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"imdb_rating\"\n    ),\n    selectInput(\n      inputId = ns(\"z\"),\n      label = \"Color by:\",\n      choices = c(\n        \"Title Type\" = \"title_type\",\n        \"Genre\" = \"genre\",\n        \"MPAA Rating\" = \"mpaa_rating\",\n        \"Critics Rating\" = \"critics_rating\",\n        \"Audience Rating\" = \"audience_rating\"\n      ),\n      selected = \"mpaa_rating\"\n    ),\n    sliderInput(\n      inputId = ns(\"alpha\"),\n      label = \"Alpha:\",\n      min = 0, max = 1, step = 0.1,\n      value = 0.5\n    ),\n    sliderInput(\n      inputId = ns(\"size\"),\n      label = \"Size:\",\n      min = 0, max = 5,\n      value = 2\n    ),\n    textInput(\n      inputId = ns(\"plot_title\"),\n      label = \"Plot title\",\n      placeholder = \"Enter plot title\"\n    )\n  )\n}\n\n#' input values server\n#' @export\nserver &lt;- function(id) {\n  box::use(\n    shiny[moduleServer, reactive],\n  )\n\n  moduleServer(id, function(input, output, session) {\n    return(\n      reactive({\n        list(\n          \"x\" = input$x,\n          \"y\" = input$y,\n          \"z\" = input$z,\n          \"alpha\" = input$alpha,\n          \"size\" = input$size,\n          \"plot_title\" = input$plot_title\n        )\n      })\n    )\n  })\n}\n\n\nThe server function in app/view/inputs returns the same reactive list of inputs from the UI.\n\n\nThe app/view/display module contains the code for collecting and rendering the graph.\n\nThe app/logic/data and app/logic/plot modules are added to app/view/display with box::use():\n\n# app/view/display.R\n\n# import data and plot modules\nbox::use(\n  app / logic / data,\n  app / logic / plot\n)\n\nThe ui in app/view/display includes the necessary shiny functions with box::use():\n\n#' display ui\n#' @export\nui &lt;- function(id) {\n  box::use(\n    shiny[NS, tagList, tags, plotOutput]\n  )\n  ns &lt;- NS(id)\n  # use data$movies_data() ----\n  tagList(\n    tags$br(),\n    tags$p(\n      \"These data were obtained from\",\n      tags$a(\"IMBD\", href = \"http://www.imbd.com/\"), \"and\",\n      tags$a(\"Rotten Tomatoes\", href = \"https://www.rottentomatoes.com/\"), \n      \". The data represent 651 randomly sampled movies released between \n      1972 to 2014 in the United States.\"\n    ),\n    tags$hr(),\n    plotOutput(outputId = ns(\"scatterplot\")),\n    tags$hr(),\n    tags$blockquote(\n      tags$em(\n        tags$h6(\n          \"The code for this application comes from the \",\n          tags$a(\"Building web applications with Shiny\",\n            href = \"https://rstudio-education.github.io/shiny-course/\"\n          ),\n          \"tutorial\"\n        )\n      )\n    )\n  )\n}\n\nThe server function adds the ggplot2, shiny, tools, and stringr functions with box::use() for creating the plot output, and imports the movies data with data$movies_data():\n\n#' display server\n#' @export\nserver &lt;- function(id, var_inputs) {\n\n  # load \n  box::use(\n    ggplot2[labs, theme_minimal, theme],\n    shiny[NS, moduleServer, plotOutput, reactive, renderPlot],\n    tools[toTitleCase],\n    stringr[str_replace_all]\n  )\n\n  moduleServer(id, function(input, output, session) {\n\n    # use data$movies_data() ----\n    movies &lt;- data$movies_data()\n\n    inputs &lt;- reactive({\n      plot_title &lt;- toTitleCase(var_inputs()$plot_title)\n      list(\n        x = var_inputs()$x,\n        y = var_inputs()$y,\n        z = var_inputs()$z,\n        alpha = var_inputs()$alpha,\n        size = var_inputs()$size,\n        plot_title = plot_title\n      )\n    })\n\n    output$scatterplot &lt;- renderPlot({\n      # use plot$scatter_plot() ----\n      plot &lt;- plot$scatter_plot(\n        df = movies,\n        x_var = inputs()$x,\n        y_var = inputs()$y,\n        col_var = inputs()$z,\n        alpha_var = inputs()$alpha,\n        size_var = inputs()$size\n      )\n      plot +\n        labs(\n          title = inputs()$plot_title,\n          x = str_replace_all(\n            toTitleCase(inputs()$x ), \"_\", \" \" ),\n          y = str_replace_all(\n            toTitleCase(inputs()$y), \"_\", \" \" )\n        ) +\n        theme_minimal() +\n        theme(legend.position = \"bottom\")\n    })\n  })\n}\n\n\nAfter composing the module in app/view/display.R, I’ll add testthat tests for the app/logic/ and app/view modules.\n\nModule tests\nWe can test the application modules with Shiny’s testServer() function. First we’ll test that the reactive list of inputs is returned from app/view/inputs:\n\n# import testthat and shiny::testServer()\nbox::use(\n  testthat[describe, it, expect_equal],\n  shiny[testServer]\n)\n\n# import inputs module\nbox::use(\n  app / view / inputs\n)\n\ndescribe(\"Feature: Server Reactive Values Verification\n  As a Shiny app developer,\n  I want to ensure that the server function returns a list of reactive values \n  So that I can confirm the server's responsiveness to input changes.\", \n  code = {\n  it(\"Scenario: Checking the return values of the server function\n    Given a server function inputs$server for handling reactive inputs\n    When I create a server object and set reactive input values as:\n      | input       | value            |\n      | x           | audience_score   |\n      | y           | imdb_rating      |\n      | z           | mpaa_rating      |\n      | alpha       | 0.75             |\n      | size        | 3                |\n      | plot_title  | Example title    |\n    And I compare the returned values from the server\n    Then the returned values should match the following list:\n      | key        | value            |\n      | x          | audience_score   |\n      | y          | imdb_rating      |\n      | z          | mpaa_rating      |\n      | alpha      | 0.75             |\n      | size       | 3                |\n      | plot_title | Example title    |\", \n    code = {\n    # create server object\n    testServer(app = inputs$server, expr = {\n      # create list of output vals\n      test_vals &lt;- list(\n        x = \"audience_score\",\n        y = \"imdb_rating\",\n        z = \"mpaa_rating\",\n        alpha = 0.75,\n        size = 3,\n        plot_title = \"Example title\")\n      # change inputs\n      session$setInputs(x = \"audience_score\",\n                        y = \"imdb_rating\",\n                        z = \"mpaa_rating\",\n                        alpha = 0.75,\n                        size = 3,\n                        plot_title = \"Example title\")\n      # test class\n      expect_equal(\n        object = session$returned(),\n        expected = test_vals\n      )\n   })\n  })\n})\n\nWe’ll also want to make sure the reactive inputs are passed from the app/view/inputs/ module to the app/view/display/ module.\n\ndescribe(\"Feature: Server Acceptance of Reactive Values\n  As a Shiny app developer,\n  I want to verify that the display server can accept a list of reactive values\n  So that I can ensure the interactive elements of the app respond as expected.\",\n  code = {\n  it(\"Scenario: Confirming the server's handling of reactive input values\n    Given a server function display$server for processing reactive inputs\n    When I test the server with a list of reactive inputs:\n      | input      | value            |\n      | x          | critics_score    |\n      | y          | imdb_rating      |\n      | z          | mpaa_rating      |\n      | alpha      | 0.5              |\n      | size       | 2                |\n      | plot_title | Enter Plot Title |\n    Then the server should correctly receive and process the reactive inputs\n    And the inputs received by the server should match the specified values\",\n    code = {\n    # test inputs to display$server\n    testServer(\n      app = display$server,\n      args = list(\n        # include list of reactive inputs\n        var_inputs =\n          reactive(\n            list(\n                 x = \"critics_score\",\n                 y = \"imdb_rating\",\n                 z = \"mpaa_rating\",\n                 alpha = 0.5,\n                 size = 2,\n                 plot_title = \"Enter Plot Title\"\n                )\n            )\n      ),\n      expr = {\n        expect_equal(\n          # test against input reactive list\n          object = inputs(),\n          expected = list(\n            x = \"critics_score\",\n            y = \"imdb_rating\",\n            z = \"mpaa_rating\",\n            alpha = 0.5,\n            size = 2,\n            plot_title = \"Enter Plot Title\"\n          )\n        )\n    })\n  })\n})\n\nThese tests confirm the reactive values are passed between the app/view/inputs and the app/view/display modules.\n\n\nRunning tests\nRunning the testthat tests in rap app is slightly different than executing tests in an R package. The standard devtools functions and keyboard shortcuts aren’t available, but rhino comes with a rhino::test_r() helper function to run all the tests in the testthat/ folder:\n\ntests/testthat/\n├── test-data.R\n├── test-display.R\n├── test-inputs.R\n├── test-main.R\n└── test-plot.R\n\n1 directory, 5 files\n\n\nrhino::test_r()\n\n✔ | F W  S  OK | Context\n✔ |          4 | data [1.3s]                                                                                                               \n✔ |          5 | display [1.2s]                                                                                                            \n✔ |          2 | inputs                                                                                                                    \n✔ |          1 | plot                                                                                                                      \n\n══ Results ═════════════════════════════════════════════════════════════════════\nDuration: 3.3 s\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 12 ]"
  },
  {
    "objectID": "rhino.html#appmain.r",
    "href": "rhino.html#appmain.r",
    "title": "the rhino framework",
    "section": "app/main.R",
    "text": "app/main.R\nAfter the app/logic/ and app/view/ code has been written and tested, the modules and layout functions can be included in app/main.R.\n\nbox::use() is used to import the shiny and shinythemes functions:\n\n# app/main.R\n\n# shiny functions\nbox::use(\n  shiny[\n    NS, fluidPage, sidebarLayout, sidebarPanel, \n    mainPanel, fluidRow, column, tags, icon,\n    plotOutput, moduleServer, renderPlot\n  ],\n  shinythemes[shinytheme]\n)\n\n# import modules\nbox::use(\n  # load inputs module ----\n  app / view / inputs,\n  # load display module ----\n  app / view / display\n)\n\n\nThe ui() and server() functions in app/main look very similar to the movies_ui() and movies_server() functions, except we access the modules using the $ operator.\n\nThe ui() function includes both input$ui() and display$ui().\n\n#' rap ui\n#' @export\nui &lt;- function(id) {\n  ns &lt;- NS(id)\n  fluidPage(\n    theme = shinytheme(\"spacelab\"),\n    sidebarLayout(\n      sidebarPanel(\n        # use inputs module UI ----\n        inputs$ui(ns(\"vals\"))\n      ),\n      mainPanel(\n        fluidRow(\n          column(\n            width = 12,\n              tags$h3(\"rap\")\n            )\n        ),\n        fluidRow(\n          column(\n            width = 1,\n            offset = 11,\n            # example info button ---\n            tags$button(\n              id = \"help-button\",\n              icon(\"info\"),\n              # add 'onclick' after rhino::build_sass()\n              # and rhino::build_js()\n              onclick = \"App.showHelp()\"\n            )\n          )\n        ),\n        fluidRow(\n          column(\n            width = 12,\n            # use display module UI ----\n            display$ui(ns(\"disp\"))\n          )\n        )\n      )\n    )\n  )\n}\n\nThe server function in app/main.R calls the inputs$server(), collects the input values as selected_vars, and passed these to display$server():\n\n#' rap server\n#' @export\nserver &lt;- function(id) {\n  moduleServer(id, function(input, output, session) {\n    # use inputs module server ----\n    selected_vars &lt;- inputs$server(id = \"vals\")\n    # use display module server ----\n    display$server(\n      id = \"disp\",\n      var_inputs = selected_vars\n    )\n  })\n}\n\n\nAfter saving all the module files and app/main.R, we can run the app using app.R:\n\n\n\n\n\n(a)\n\n\nFigure 2: initial rap launch"
  },
  {
    "objectID": "rhino.html#adding-non-r-code",
    "href": "rhino.html#adding-non-r-code",
    "title": "the rhino framework",
    "section": "Adding non-R code",
    "text": "Adding non-R code\nIt’s fairly straightforward to add external resources (i.e., JavaScript, CSS, Sass, etc.) to rhino apps. I’ll use the example from the website to demonstrate because it adds both CSS and JavaScript to the codebase.\n\nUpdate the mainPanel() to include the title, info button, and display module in app/main.R:\n\ntags$button(\n  id = \"help-button\",\n  icon(\"info\"),\n  # add 'onclick' after rhino::build_sass()\n  # and rhino::build_js()\n  onclick = \"App.showHelp()\"\n)\n\n\nThe following CSS is added to app/styles/main.css in the container for the button.\n\n// app/styles/main.scss\n\n.components-container {\n  display: inline-grid;\n  grid-template-columns: 1fr 1fr;\n  width: 100%;\n\n  .component-box {\n    padding: 10px;\n    margin: 10px;\n    box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);\n  }\n}\n\nh1 {\n  text-align: center;\n  font-weight: 900;\n}\n\n#help-button {\n  position: fixed;\n  top: 0;\n  right: 0;\n  margin: 10px;\n}\n\nRun rhino::build_sass() to create the app/static/css/app.min.css file (requires node.js)\n\n\nrhino::build_sass()\n\nadded 748 packages in 49s\nbuild-sass\nsass --no-source-map --style=compressed \n  ../app/styles/main.scss:../app/static/css/app.min.css\n\nThis tells me app.min.css has been added to in app/static/css/\n\napp/static/\n      └── css\n           └── app.min.css\n\nAdd the following to app/js/index.js:\n\nexport function showHelp() {\nalert('Learn more about shiny frameworks: https://mjfrigaard.github.io/posts/my-rhino-app/');\n}\n\nRun rhino::build_js() to build the app/static/js/app.min.js (requires node.js)\n\n\nrhino::build_js()\n\nbuild-js\nwebpack\n\nasset app.min.js 502 bytes [emitted] [minimized] (name: main)\nruntime modules 670 bytes 3 modules\n../app/js/index.js 126 bytes [built] [code generated]\nwebpack 5.69.0 compiled successfully in 1300 ms\n\nThe output tells me the app.min.js has been created in app/static/js\n\napp/static/\n      └── js\n          └── app.min.js\n\nNow when I save everything and click ‘Run App’ in app.R I should see the info button (and message):\n\n\n\n\n\n\n\nFigure 3: Adding .js to app/js/index.js\n\n\n\n\n\n\n\n\n\nFigure 4: Adding .js to app/js/index.js ‘on click’"
  },
  {
    "objectID": "rhino.html#system-tests-shinytest2",
    "href": "rhino.html#system-tests-shinytest2",
    "title": "the rhino framework",
    "section": "System tests (shinytest2)",
    "text": "System tests (shinytest2)\nSystem tests can also be written using shinytest2. The tests below come from System tests chapter of Shiny App-Packages.17\nStart by installing shinytest2 and shinyvalidate:18\n\nThis will update the dependencies.R file (and might require a call to renv::snapshot())\n\nrhino::pkg_install(c(\"shinytest2\", \"shinyvalidate\"))\n\nCreate new tests with shinytest2::record_test() the same way you would for a standard Shiny app:\n\nshinytest2::record_test()\n\n\n\n\n\n\n\n(a)\n\n\nFigure 5: Test recorder\n\n\nThis produces the following in the Console:\n\n{shiny} R stderr ----------- Loading required package: shiny\n{shiny} R stderr ----------- Running application in test mode.\n{shiny} R stderr ----------- Listening on http://127.0.0.1:5391\n• Saving test runner: tests/testthat.R\n• Saving test file: tests/testthat/test-shinytest2.R\n✔ Adding 'shinytest2::load_app_env()' to 'tests/testthat/setup-shinytest2.R'\n• Modify '/rap/tests/testthat/test-shinytest2.R'\n• Running recorded test: tests/testthat/test-shinytest2.R\n✔ | F W  S  OK | Context\n✔ |   2      1 | shinytest2 [11.4s]                                           \n\n─────────────────────────────────────────────────────────────────────────────\nWarning (test-shinytest2.R:13:3): {shinytest2} recording: feature-01\nAdding new file snapshot: 'tests/testthat/_snaps/feature-01-001_.png'\n\nWarning (test-shinytest2.R:13:3): {shinytest2} recording: feature-01\nAdding new file snapshot: 'tests/testthat/_snaps/feature-01-001.json'\n─────────────────────────────────────────────────────────────────────────────\n\n══ Results ══════════════════════════════════════════════════════════════════\nDuration: 11.8 s\n\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 1 ]\n\n\nModules in rhino\n\n\n\n\nThe shinytest2 tests for moviesApp are below. Note how the nested modules are called from the app Driver (app$set_inputs()):\n\n\napp$set_inputs(`vars-y` = \"imdb_num_votes\")\napp$set_inputs(`vars-x` = \"critics_score\")\napp$set_inputs(`vars-z` = \"genre\")\napp$set_inputs(`vars-alpha` = 0.7)\napp$set_inputs(`vars-size` = 3)\napp$set_inputs(`vars-plot_title` = \"New plot title\")\n\n\n\n\n\n\n\nIn rap, the box modules have another level of encapsulation (i.e., vars-y becomes app-vals-y):\n\n\napp$set_inputs(`app-vals-y` = \"imdb_num_votes\")\napp$set_inputs(`app-vals-x` = \"critics_score\")\napp$set_inputs(`app-vals-z` = \"genre\")\napp$set_inputs(`app-vals-alpha` = 0.7)\napp$set_inputs(`app-vals-size` = 3)\napp$set_inputs(`app-vals-plot_title` = \"New plot title\")\n\n\n\nIt’s important to keep these differences in mind when writing shinytest2 tests.19\n\n\nBDD system tests\nI’ve provided a few shinytest2 example tests for the data visualization user-input features using testthats BDD functions:20\n\n\nshow/hide contents of tests/testthat/test-app-feature-01.R\nlibrary(shinytest2)\ndescribe(\"Feature 1: Scatter plot data visualization dropdowns\n           As a film data analyst\n           I want to explore variables in the movie review data\n           So that I can analyze relationships between movie reivew sources\", {\n             \n  describe(\"Scenario A: Change dropdown values for plotting\n             Given the movie review application is loaded\n             When I choose the variable [critics_score] for the x-axis\n             And I choose the variable [imdb_num_votes] for the y-axis\n             And I choose the variable [genre] for the color\", {\n    it(\"Then the scatter plot should show [critics_score] on the x-axis\n         And the scatter plot should show [imdb_num_votes] on the y-axis\n         And the points on the scatter plot should be colored by [genre]\", {\n              app &lt;- AppDriver$new(name = \"feature-01-senario-a\", \n                                     height = 800, width = 1173)\n                app$set_inputs(`app-vars-y` = \"imdb_num_votes\")\n                app$set_inputs(`app=vars-x` = \"critics_score\")\n                app$set_inputs(`app-vars-z` = \"genre\")\n                app$expect_values()\n       })\n   })\n             \n  describe(\"Scenario B: Change dropdown values for plotting\n              Given the movie review application is loaded\n              When I choose the size of the points to be [0.7]\n              And I choose the opacity of the points to be [3]\n              And I enter '[New plot title]' for the plot title\", {\n         it(\"Then the size of the points on the scatter plot should be [3]\n              And the opacity of the points on the scatter plot should be [0.7]\n              And the title of the plot should be '[New Plot Title]'\", {\n              app &lt;- AppDriver$new(name = \"feature-01-senario-b\", \n                                     height = 800, width = 1173)\n                app$set_inputs(`app-vars-alpha` = 0.7)\n                app$set_inputs(`app-vars-size` = 3)\n                app$set_inputs(`app-vars-plot_title` = \"New plot title\")\n                app$expect_values()\n        })\n    })\n})\n\n\nNote that these tests combine testthat’s describe() and it() functions with the Gherkin syntax."
  },
  {
    "objectID": "rhino.html#system-tests-cypress",
    "href": "rhino.html#system-tests-cypress",
    "title": "the rhino framework",
    "section": "System tests (Cypress)",
    "text": "System tests (Cypress)\nrhino apps extend the test suite to include the Cypress test framework. The Cypress testing framework relies on node.js. Every machine/setup is a little different, but I use homebrew, so I installed node with the following:\n# remove to get a fresh start\nbrew uninstall node\n# update homebrew \nbrew update\nbrew upgrade\n# file cleanup\nbrew cleanup\nInstall node:\nbrew install node\nLink node (I had to use the --overwrite flag):\nbrew link --overwrite node\nLinking /usr/local/Cellar/node/21.5.0... 112 symlinks created.\nRun the post-install:\nbrew postinstall node\n==&gt; Postinstalling node\nVerify versions:\nnode --version\nv21.5.0\nnpm -v\n10.2.4\n\nClicks & message modules\nThe Cypress tests below follow the example from the rhino website. Below are two modules (clicks.R and message.R) that have been included in app/view (as app/view/message.R and app/view/clicks.R).\nBoth modules contain an actionButton() and textOutput(). Using app/view/clicks or app/view/message also requires adding both modules in the app/main.R file with box::use():\n\n\napp/main.R\nThe updated app/main.R file:\n\n\nshow/hide app/main.R\n# app/main.R\n\n# shiny functions\nbox::use(\n  shiny[\n    NS, fluidPage, sidebarLayout, sidebarPanel, \n    mainPanel, fluidRow, column, tags, icon,\n    plotOutput, moduleServer, renderPlot,\n    br, hr\n  ],\n  shinythemes[shinytheme]\n)\n\n# import modules ----\nbox::use(\n  app / view / inputs,\n  app / view / display,\n  app / view / clicks,\n  app / view / message,\n)\n\n#' rap ui\n#' @export\nui &lt;- function(id) {\n  ns &lt;- NS(id)\n  fluidPage(theme = shinytheme(\"spacelab\"),\n    sidebarLayout(\n      sidebarPanel(\n        inputs$ui(ns(\"vals\"))\n        ),\n      mainPanel(\n        fluidRow(\n1              clicks$ui(ns(\"clicks\")),\n              message$ui(ns(\"message\"))\n          ),\n        fluidRow(\n          column(\n            width = 1,\n            offset = 11,\n            tags$button(id = \"help-button\",\n              icon(\"info\"),\n              # add 'onclick' after rhino::build_sass()\n              # and rhino::build_js()\n              onclick = \"App.showHelp()\")\n          )\n        ),\n        fluidRow(\n            column(\n              width = 12,\n              tags$h3(\"rap\"),\n            display$ui(ns(\"disp\"))\n            )\n          )\n        )\n      )\n    )\n}\n\n#' rap server\n#' @export\nserver &lt;- function(id) {\n  moduleServer(id, function(input, output, session) {\n    selected_vars &lt;- inputs$server(id = \"vals\")\n    display$server(\n      id = \"disp\",\n      var_inputs = selected_vars\n    )\n  })\n  \n  moduleServer(id, function(input, output, session) {\n2    clicks$server(\"clicks\")\n    message$server(\"message\")\n  })\n  \n}\n\n\n\n1\n\ninclude app/view/clicks.R and app/view/message.R modules in UI\n\n\n2\n\ninclude app/view/clicks.R and app/view/message.R modules in server\n\n\n\n\nThe new ‘clicks’ and ‘message’ buttons are visible in the mainPanel():\n\n\n\n\n\n\n\nRunning Cypress tests\nCypress tests are stored in the tests/cypress/integration/ folder:21\ntests/cypress\n└── integration\n    └── app.spec.js\n\n2 directories, 1 file\nThe initial call to rhino::test_e2e() should note if it is your first time using cypress (and might include an update or two).22\n\n&gt; test-e2e\n&gt; start-server-and-test run-app http://localhost:3333 run-cypress\n\n1: starting server using command \"npm run run-app\"\nand when url \"[ 'http://localhost:3333' ]\" is responding with HTTP status code 200\nrunning tests using command \"npm run run-cypress\"\n\n\n&gt; run-app\n&gt; cd .. && Rscript -e \"shiny::runApp(port = 3333)\"\n\nLoading required package: shiny\n\nListening on http://127.0.0.1:3333\n\n&gt; run-cypress\n&gt; cypress run --project ../tests\n\nIt looks like this is your first time using Cypress: 7.7.0\n\n[STARTED] Task without title.\n[TITLE]  Verified Cypress!       /Users/mjfrigaard/Library/Caches/Cypress/7.7.0/Cypress.app\n[SUCCESS]  Verified Cypress!       /Users/mjfrigaard/Library/Caches/Cypress/7.7.0/Cypress.app\n\nOpening Cypress...\n\nThe initial test run output (from the test stored in tests/cypress/integration/app.spec.js) is below:\n\n\nhide/view initial tests/cypress/integration/app.spec.js test\n  (Run Starting)\n\n  ┌────────────────────────────────────────────────────────────────────────────────────────────────┐\n  │ Cypress:    7.7.0                                                                              │\n  │ Browser:    Electron 89 (headless)                                                             │\n  │ Specs:      1 found (app.spec.js)                                                              │\n  └────────────────────────────────────────────────────────────────────────────────────────────────┘\n\n\n────────────────────────────────────────────────────────────────────────────────────────────────────\n                                                                                                    \n  Running:  app.spec.js                                                                     (1 of 1)\n\n  app\n    ✓ starts (691ms)\n\n\n  1 passing (716ms)\n\nNew names:\n• `` -&gt; `...1`\n\n  (Results)\n\n  ┌────────────────────────────────────────────────────────────────────────────────────────────────┐\n  │ Tests:        1                                                                                │\n  │ Passing:      1                                                                                │\n  │ Failing:      0                                                                                │\n  │ Pending:      0                                                                                │\n  │ Skipped:      0                                                                                │\n  │ Screenshots:  0                                                                                │\n  │ Video:        true                                                                             │\n  │ Duration:     0 seconds                                                                        │\n  │ Spec Ran:     app.spec.js                                                                      │\n  └────────────────────────────────────────────────────────────────────────────────────────────────┘\n\n\n  (Video)\n\n  -  Started processing:  Compressing to 32 CRF                                                     \n  -  Finished processing: /Users/mjfrigaard/projects/apps/sfw/_apps/rap/tests/cypress     (1 second)\n                          /videos/app.spec.js.mp4                                                   \n\n\nOpening `/dev/tty` failed (6): Device not configured\nresize:  can`t open terminal /dev/tty\n================================================================================\n\n  (Run Finished)\n\n       Spec                                              Tests  Passing  Failing  Pending  Skipped  \n  ┌────────────────────────────────────────────────────────────────────────────────────────────────┐\n  │ ✔  app.spec.js                              714ms        1        1        -        -        - │\n  └────────────────────────────────────────────────────────────────────────────────────────────────┘\n    ✔  All specs passed!                        714ms        1        1        -        -        -  \n\n\nThe Cypress output lists the test file name as Spec or Specs, and gives us a detailed report of the test result and any artifacts (like videos or images).\n\ntests/cypress\n├── integration\n│   └── app.spec.js\n├── screenshots\n└── videos\n    └── app.spec.js.mp4\n\n4 directories, 2 files\n\n\n\nWriting Cypress tests\nI’ll include the first test for the app/view/message module from the rhino cypress tutorial in the tests/cypress/integration/ folder:\n// tests/cypress/integration/message.cy.js\n\ndescribe(\"Show message\", () =&gt; {\n  beforeEach(() =&gt; {\n    cy.visit(\"/\");\n  });\n\n  it(\"'Show message' button exists\", () =&gt; {\n    cy.get(\".message button\").should(\"have.text\", \"Show message\");\n  });\n\n});\nI love the use of testthat’s BDD functions with cypress, because we can see the feature and scenario described in the test itself.\nAfter running the test with rhino::test_e2e(), we see the output now includes two videos (one for each test):\n\n\nhide/view tests/cypress/integration/message.cy.js test\n  (Run Starting)\n\n  ┌────────────────────────────────────────────────────────────────────────────────────────────────┐\n  │ Cypress:    7.7.0                                                                              │\n  │ Browser:    Electron 89 (headless)                                                             │\n  │ Specs:      2 found (app.spec.js, message.cy.js)                                               │\n  └────────────────────────────────────────────────────────────────────────────────────────────────┘\n\n\n────────────────────────────────────────────────────────────────────────────────────────────────────\n                                                                                                    \n  Running:  message.cy.js                                                                   (2 of 2)\n\n\n  Show message\n    ✓ 'Show message' button exists (546ms)\n\n\n  1 passing (612ms)\n\nNew names:\n• `` -&gt; `...1`\n\n  (Results)\n\n  ┌────────────────────────────────────────────────────────────────────────────────────────────────┐\n  │ Tests:        1                                                                                │\n  │ Passing:      1                                                                                │\n  │ Failing:      0                                                                                │\n  │ Pending:      0                                                                                │\n  │ Skipped:      0                                                                                │\n  │ Screenshots:  0                                                                                │\n  │ Video:        true                                                                             │\n  │ Duration:     0 seconds                                                                        │\n  │ Spec Ran:     message.cy.js                                                                    │\n  └────────────────────────────────────────────────────────────────────────────────────────────────┘\n\n\n  (Video)\n\n  -  Started processing:  Compressing to 32 CRF                                                     \n  -  Finished processing: /Users/mjfrigaard/projects/apps/sfw/_apps/rap/tests/cypress     (1 second)\n                          /videos/message.cy.js.mp4                                                 \n\n\nOpening `/dev/tty` failed (6): Device not configured\nresize:  can`t open terminal /dev/tty\n================================================================================\n\n  (Run Finished)\n\n       Spec                                              Tests  Passing  Failing  Pending  Skipped  \n  ┌────────────────────────────────────────────────────────────────────────────────────────────────┐\n  │ ✔  app.spec.js                              776ms        1        1        -        -        - │\n  ├────────────────────────────────────────────────────────────────────────────────────────────────┤\n  │ ✔  message.cy.js                            596ms        1        1        -        -        - │\n  └────────────────────────────────────────────────────────────────────────────────────────────────┘\n    ✔  All specs passed!                        00:01        2        2        -        -        -  \n\n\n\ntests/cypress\n├── integration\n│   ├── app.spec.js\n│   └── message.cy.js\n├── screenshots\n└── videos\n    ├── app.spec.js.mp4\n    └── message.cy.js.mp4\n\n4 directories, 4 files\n\nIf we view the contents of tests/cypress/videos/message.cy.js.mp4, we see it opens our app and verifies the message button:\n\n\n\n\n\n(a) Cypress test recording\n\n\nFigure 6: Contents of tests/cypress/videos/message.cy.js.mp4\n\n\n\n\nInteractive tests\nAfter adding the second test for the app/view/message module, we’ll run the test using interactive = TRUE, which opens the Cypress app window:\n\n\n\n\n\n(a) Cypress app\n\n\nFigure 7: The Cypress appliction\n\n\nAfter the application opens, you’ll be able to select the browser (I have Chrome selected)\n\n\n\n\n\n(a) Run cypress tests\n\n\nFigure 8: Run the tests in tests/cypress/integration/\n\n\nClicking on Run 2 integration specs will launch the application in Chrome. You’ll see the tests loading in the sidebar before they are run.\n\n\n\n\n\n(a) Chrome from cypress\n\n\nFigure 9: Open application in Chrome from cypress\n\n\nBelow is a screenshot of our tests listed in the sidebar:\n\n\n\n\n\n(a) Chrome tests\n\n\nFigure 10: Tests list\n\n\nCypress quickly runs through each test:\n\n\n\n\n\n(a) Running tests\n\n\nFigure 11: Running tests in Chrome\n\n\nAnd we can see the final result at the menu bar:\n\n\n\n\n\n(a) Test results\n\n\nFigure 12: Test results in Chrome\n\n\nThe Cypress documentation is worth reading through, because there are other features I haven’t covered here."
  },
  {
    "objectID": "rhino.html#recap",
    "href": "rhino.html#recap",
    "title": "the rhino framework",
    "section": "Recap",
    "text": "Recap\n\nMost of the development takes place in app/logic and app/view (using box modules). The separation of the ‘business logic’ workflow from the ‘app view’ code provides a nice division of labor for each module, and the use of box modules make it easy to move components into the application in app/main.R.\nNew JavaScript or CSS code requires a corresponding rhino (rhino::build_js() or rhino::build_sass()), and requires installing node.js.\n\nThese functions create output files in app/static/js/app.min.js and app/static/css/app.min.css that are used in the application.\n\nTesting with testthat is similar to a standard R package, but using box modules in tests takes some getting used to.\n\nCypress tests are an excellent way to perform end-to-end tests (faster than shinytest2), but requires some overhead in learning the syntax (which combines testthat functions with CSS selectors, etc.)."
  },
  {
    "objectID": "rhino.html#footnotes",
    "href": "rhino.html#footnotes",
    "title": "the rhino framework",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThe code used to build the rhino app is available here.↩︎\nrhino has a ‘minimal app.R’ philosophy, and the call to rhino::app() performs multiple operations beyond shiny::runApp()↩︎\nRead more about how to use config.yml in the Environments section of the How to: Manage secrets and environments vignette.↩︎\nRead more about rhino.yml in the Explanation: Configuring Rhino - rhino.yml vignette.↩︎\ndependencies.R is covered in the Manage Dependencies vignette on the package website.↩︎\nRead more about getting started with renv.↩︎\nTesting with Cypress is also covered in the ‘Use shinttest2 vignette’.↩︎\nRead more about rhino unit tests↩︎\nAdd-on packages can also be included in R packages by adding the @importFrom or @import tags from roxygen2, which writes the NAMESPACE directives↩︎\ninstall.packages() downloads and installs packages from a repo like CRAN or GitHub, and library (or require) loads and attaches the add-on packages to the search list.↩︎\nAdding a package to the Imports field in the DESCRIPTION will download/install the add-on package when your package is installed, but not attach it to the search list (the Depends field will install and attach the package).↩︎\nlibrary(tidyverse) is typically used to install the core tidyverse packages (ggplot2, dplyr, tidyr, readr, purrr, tibble, stringr, forcats), but this is not advised during package development.↩︎\nThis is how box “completely replaces the base R library and require functions” - box documentation.↩︎\nI’d start with “the hierarchy of module environments” vignette. I’ve also created a collection of box module examples in the rbox repo.↩︎\nrhino apps come with an app/logic/ folder, which is used to store code for “data manipulation, generating non-interactive plots and graphs, or connecting to an external data source, but outside of definable inputs, it doesn’t interact with or rely on shiny in any way.”↩︎\nThe __init__.R files are covered on the rhino website↩︎\nThese system tests are written for a Shiny app in a standard R package.↩︎\nThese steps are covered in the Appsilon article, ‘How-to: Use shinytest2’.↩︎\nThis is referenced in the Cypress tutorial when trying to identify the text output from the app/view/message module.↩︎\nThis test is covered in BDD test templates section of Shiny App-Packages.↩︎\nThe folder names are slightly different in the Cypress tutorial, but if you replace e2e with integration in the file paths, everything works!↩︎\nThe rhino documentation also mentions updates, ‘since this is the first time you use one of the functionalities that depend on Node.js, it needs to install all the required libraries. Don’t worry, this is just a one-time step and is done automatically.’↩︎"
  },
  {
    "objectID": "leprechaun.html",
    "href": "leprechaun.html",
    "title": "The leprechaun framework",
    "section": "",
    "text": "leprechaun apps are built much like standard R packages (with devtools and usethis), but they’re designed with the intention of being a ‘leaner and smaller’ version of golem:1"
  },
  {
    "objectID": "leprechaun.html#getting-started",
    "href": "leprechaun.html#getting-started",
    "title": "The leprechaun framework",
    "section": "Getting started",
    "text": "Getting started\nCreate a leprechaun app just like you would a new R package:\n\nusethis::create_package(\"lap\")\n\n\n✔ Creating '../projects/lap/'\n✔ Setting active project to '/Users/mjfrigaard/projects/lap'\n✔ Creating 'R/'\n✔ Writing 'DESCRIPTION'\n✔ Writing 'NAMESPACE'\n✔ Writing 'lap.Rproj'\n✔ Adding '^lap\\\\.Rproj$' to '.Rbuildignore'\n✔ Adding '.Rproj.user' to '.gitignore'\n✔ Adding '^\\\\.Rproj\\\\.user$' to '.Rbuildignore'\n✔ Opening '/Users/mjfrigaard/projects/lap/' in new RStudio session\n\nAfter the new project opens, install and load the leprechaun package, then run leprechaun::scaffold():2\n\ninstall.packages(\"leprechaun\")\nlibrary(leprechaun)\nleprechaun::scaffold(ui = \"fluidPage\")\n\n\n── Scaffolding leprechaun app ─────────────────────────────────────────\n\n── Creating lock file ──\n\n✔ Creating .leprechaun\n\n── Adding dependencies ──\n\n✔ Adding 'shiny' to Imports in DESCRIPTION\n✔ Adding 'bslib' to Imports in DESCRIPTION\n✔ Adding 'htmltools' to Imports in DESCRIPTION\n✔ Adding 'pkgload' to Suggests in DESCRIPTION\n\n\n── Generating code ──\n\n✔ Creating R/ui.R\n✔ Creating R/assets.R\n✔ Creating R/run.R\n✔ Creating R/server.R\n✔ Creating R/leprechaun-utils.R\n✔ Creating R/_disable_autoload.R\n✔ Creating R/zzz.R\n✔ Creating R/input-handlers.R\n\n✔ Creating inst/dev\n✔ Creating inst/assets\n✔ Creating inst/img\n✔ Creating inst/run/app.R\n\n── Ignoring files ──\n\n✔ Adding '^\\\\.leprechaun$' to '.Rbuildignore'"
  },
  {
    "objectID": "leprechaun.html#package-files",
    "href": "leprechaun.html#package-files",
    "title": "The leprechaun framework",
    "section": "Package files",
    "text": "Package files\nleprechaun::scaffold() results in the following folder tree:\n\nlap/\n  ├── DESCRIPTION\n  ├── NAMESPACE\n  ├── R/\n  │   ├── _disable_autoload.R\n  │   ├── assets.R\n  │   ├── input-handlers.R\n  │   ├── leprechaun-utils.R\n  │   ├── run.R\n  │   ├── server.R\n  │   ├── ui.R\n  │   └── zzz.R\n  ├── inst/\n  │   ├── assets/\n  │   ├── dev/\n  │   ├── img/\n  │   └── run/\n  │       └── app.R\n  └── lap.Rproj\n\n7 directories, 12 files\n\nThe standard R package files and folders (DESCRIPTION, NAMESPACE, R/, and lap.Rproj) are accompanied by multiple sub-folders in inst/ (recall that inst/ contents are available in the package when the package is installed).\n\nleprechaun files\nThe initial application files are created using leprechaun::scaffold(), which takes the following options as function arguments:\n\nui controls the application layout (can be \"fluidPage\" or \"navbarPage\", defaults to \"navbarPage\")\nbs_version Bootstrap version (“If shiny &gt; 1.6 is installed defaults to version 5, otherwise version 4” )\noverwrite: Overwrite all files?\n\n\n\n└── R/\n    ├── _disable_autoload.R\n    ├── assets.R\n    ├── input-handlers.R\n    ├── leprechaun-utils.R\n    ├── run.R\n    ├── server.R\n    ├── ui.R\n    └── zzz.R\n\n\n_disable_autoload.R disables Shiny’s loadSupport(). By default, Shiny will load “any top-level supporting .R files in the R/ directory adjacent to the app.R/server.R/ui.R files.”\nassets.R: contains the serveAssets() function, which will identify the modules using CSS or JavaScript and create dependencies, a list of metadata on the app\ninput-handlers.R: contains leprechaun_handler_df() and leprechaun_handler_list() for “converting the input received from the WebSocket to a data.frame/list”\n.onAttach() registers the two input handlers above\n\nregisterInputHandler(): “When called, Shiny will use the function provided to refine the data passed back from the client (after being deserialized by jsonlite) before making it available in the input variable of the server.R file”)\n\nleprechaun-utils.R initially contains the make_send_message() function (which is used in the R/server.R below)\n\n\n\nApp Code\n\nrun.R contains functions for running the production (run()) and development version of the application (run_dev()):\nserver.R by default creates send_message with make_send_message(session) (see R/leprechaun-utils.R above).\nui.R holds the ui() and assets() functions. assets() loads the resources called in the R/assets.R file (see serveAssets() function above).\nzzz.R contains .onLoad(), a wrapper for system.file() and Shiny’s addResourcePath() and function (used for adding images to the application in inst/img/).\n\n\nThe inst/ folder\nThe inst/ folder contains the initial leprechaun scaffolding folders:\n\ninst/\n├── assets\n├── dev\n├── img\n└── run\n    └── app.R\n\n4 directories, 1 file\n\nassets, dev, and img will be demonstrated in the sections below. The inst/run/app.R contains calls to leprechaun::build() and pkgload::load_all() before running the app with run()\n\n# do not deploy from this file\n# see leprechaun::add_app_file()\nleprechaun::build()\n\npkgload::load_all(\n    path = \"../../\",\n    reset = TRUE,\n    helpers = FALSE\n)\n\nrun()\n\nThis file is not run directly (see the leprechaun::add_app_file() function for creating an app.R file to your app-package)."
  },
  {
    "objectID": "leprechaun.html#building-leprechaun-apps",
    "href": "leprechaun.html#building-leprechaun-apps",
    "title": "The leprechaun framework",
    "section": "Building leprechaun apps",
    "text": "Building leprechaun apps\nBuilding leprechaun apps is similar to developing an R package. New code is placed in the R/ folder, and application resources (CSS, SASS, JavaScript files) are added using one of the leprechaun::use_* functions:\n\nuse_sass()\nuse_html_utils()\n\nuse_endpoints_utils()\nuse_js_utils()\n\nMore assets can be added using the leprechaun::use_packer() function.\n\nModules\nleprechaun has an add_module() helper function for creating modules:\n\nThe initial var_input module:\n\nleprechaun::add_module(\"var_input\")\n\n\nThis creates functions for the UI and server portions of the module.\n\n\n#' var_input UI\n#' \n#' @param id Unique id for module instance.\n#' \n#' @keywords internal\nvar_inputUI &lt;- function(id){\n    ns &lt;- NS(id)\n\n    tagList(\n        h2(\"var_input\"),\n\n    )\n}\n\n\nThe initial server module:\n\n\n#' var_input Server\n#' \n#' @param id Unique id for module instance.\n#' \n#' @keywords internal\nvar_input_server &lt;- function(id){\n    moduleServer(\n        id,\n        function(\n            input, \n            output, \n            session\n            ){\n\n                ns &lt;- session$ns\n                send_message &lt;- make_send_message(session)\n\n                # your code here\n        }\n    )\n}\n\n# UI\n# var_inputUI('id')\n\n# server\n# var_input_server('id')\n\n\nNote the send_message &lt;- make_send_message(session) in var_input_server(). We’ll cover how this is used in the JavaScript section below.\n\n\n\n\n\n\nTip: @keywords internal\n\n\n\n\n\n\nThe module contents are similar to golem, but instead of using the @noRd tag, these functions include @keywords internal (which can be used to document your package).\n\n\n\n\nThe code for the var_input and plot_display modules are below.\n\nThe R/module_var_input.R file: plot_dispay collects the data from var_input and creates the plot with the custom scatter_plot() function:\n\n\nvar_inputUI &lt;- function(id) {\n  ns &lt;- NS(id)\n  tagList(\n    selectInput(\n      inputId = ns(\"y\"),\n      label = \"Y-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"audience_score\"\n    ),\n    selectInput(\n      inputId = ns(\"x\"),\n      label = \"X-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"imdb_rating\"\n    ),\n    selectInput(\n      inputId = ns(\"z\"),\n      label = \"Color by:\",\n      choices = c(\n        \"Title Type\" = \"title_type\",\n        \"Genre\" = \"genre\",\n        \"MPAA Rating\" = \"mpaa_rating\",\n        \"Critics Rating\" = \"critics_rating\",\n        \"Audience Rating\" = \"audience_rating\"\n      ),\n      selected = \"mpaa_rating\"\n    ),\n    sliderInput(\n      inputId = ns(\"alpha\"),\n      label = \"Alpha:\",\n      min = 0, max = 1, step = 0.1,\n      value = 0.5\n    ),\n    sliderInput(\n      inputId = ns(\"size\"),\n      label = \"Size:\",\n      min = 0, max = 5,\n      value = 2\n    ),\n    textInput(\n      inputId = ns(\"plot_title\"),\n      label = \"Plot title\",\n      placeholder = \"Enter plot title\"\n    )\n  )\n}\n\nvar_input_server &lt;- function(id) {\n  moduleServer(id, function(input, output, session) {\n      ns &lt;- session$ns\n      send_message &lt;- make_send_message(session)\n\n      # your code here\n      return(\n        reactive({\n          list(\n            \"y\" = input$y,\n            \"x\" = input$x,\n            \"z\" = input$z,\n            \"alpha\" = input$alpha,\n            \"size\" = input$size,\n            \"plot_title\" = input$plot_title\n          )\n        })\n      )\n    }\n  )\n}\n\n\nThe R/module_plot_display.R file\n\n\nplot_displayUI &lt;- function(id) {\n  ns &lt;- NS(id)\n  tagList(\n    tags$br(),\n    tags$blockquote(\n      tags$em(\n        tags$h6(\n          \"The code for this application comes from the \",\n          tags$a(\"Building web applications with Shiny\",\n            href = \"https://rstudio-education.github.io/shiny-course/\"\n          ),\n          \"tutorial\"\n        )\n      )\n    ),\n    plotOutput(outputId = ns(\"scatterplot\"))\n  )\n}\nplot_display_server &lt;- function(id, var_inputs) {\n  moduleServer(id, function(input, output, session) {\n\n      ns &lt;- session$ns\n      send_message &lt;- make_send_message(session)\n\n      inputs &lt;- reactive({\n        plot_title &lt;- tools::toTitleCase(var_inputs()$plot_title)\n        list(\n          x = var_inputs()$x,\n          y = var_inputs()$y,\n          z = var_inputs()$z,\n          alpha = var_inputs()$alpha,\n          size = var_inputs()$size,\n          plot_title = plot_title\n        )\n      })\n      output$scatterplot &lt;- renderPlot({\n        plot &lt;- scatter_plot(\n          # data --------------------\n          df = movies,\n          x_var = inputs()$x,\n          y_var = inputs()$y,\n          col_var = inputs()$z,\n          alpha_var = inputs()$alpha,\n          size_var = inputs()$size\n        )\n        plot +\n          ggplot2::labs(\n            title = inputs()$plot_title,\n            x = stringr::str_replace_all(\n                  tools::toTitleCase(inputs()$x), \"_\", \" \"),\n            y = stringr::str_replace_all(\n                  tools::toTitleCase(inputs()$y), \"_\", \" \")) +\n          ggplot2::theme_minimal() +\n          ggplot2::theme(legend.position = \"bottom\")\n      })\n    }\n  )\n}\n\nAfter creating the modules, adding them to the UI (R/ui.R) and server (R/server.R) is straightforward.\n\nThe R/ui.R file: the UI includes the bs_theme() function (with version set to 5).\n\n\n#' Shiny UI\n#'\n#' Core UI of package.\n#'\n#' @param req The request object.\n#'\n#' @import shiny\n#' @importFrom bslib bs_theme\n#'\n#' @keywords internal\nui &lt;- function(req) {\n  fluidPage(\n    theme = bs_theme(version = 5),\n    assets(),\n    h1(\"lap\"),\n    # Begin new code --&gt;\n    shiny::sidebarLayout(\n      shiny::sidebarPanel(\n        var_inputUI(\"vars\")\n      ),\n      shiny::mainPanel(\n        plot_displayUI(\"plot\")\n      )\n    )\n    ## End new code &lt;--\n  )\n}\n\n\nThe R/server.R file: The server also has the make_send_message() function in it by default (more on that below).\n\n\n#' Server\n#'\n#' Core server function.\n#'\n#' @param input,output Input and output list objects\n#' containing said registered inputs and outputs.\n#' @param session Shiny session.\n#'\n#' @noRd\n#' @keywords internal\nserver &lt;- function(input, output, session){\n\n    send_message &lt;- make_send_message(session)\n\n  ## New code --&gt;\n   selected_vars &lt;- var_input_server(\"vars\")\n\n   plot_display_server(\"plot\", var_inputs = selected_vars)\n   ## New code &lt;--\n\n}\n\nThe other components of lap were created using the standard usethis package development functions.\n\n\nUtility functions\n\nusethis::use_r() created R/utils_plot_display.R to hold the scatter_plot() function\n\n\nscatter_plot &lt;- function(df, x_var, y_var, col_var, alpha_var, size_var) {\n    ggplot2::ggplot(data = df,\n      ggplot2::aes(x = .data[[x_var]],\n          y = .data[[y_var]],\n          color = .data[[col_var]])) +\n      ggplot2::geom_point(alpha = alpha_var, size = size_var)\n\n}\n\nNow I can run devtools::load_all(), devtools::document(), restart and load the package, then run()\n\n\n\n\n\n\n\nFigure 1: run lap\n\n\n\n\nData\n\nmovies.RData was added to inst/extdata and loaded into the package with usethis::use_data_raw()\n\n\n\n\n\n\n\nAdding data to a package\n\n\n\n\n\n\nAfter calling usethis::use_data_raw('movies'), I can use system.file() to locate the file with the following code in data-raw/movies.R:\n## code to prepare `movies` dataset goes here\npth &lt;- system.file('extdata/movies.RData', package = 'lap')\nload(pth)\nusethis::use_data(movies, overwrite = TRUE)\n\n\n\n\n\n\nUnit tests\nThe unit tests for the scatter_plot() utility function and the module server functions are in the tests/testthat/ folder:\n\ntests\n├── testthat\n│   ├── test-module_plot_display.R\n│   ├── test-module_var_input.R\n│   └── test-utils_scatter_plot.R\n└── testthat.R\n\n2 directories, 4 files\n\nleprechaun relies on the testthat framework for testing.3 I’ve included the BDD functions (describe() and it()) to make each behavior and test clear.\n\n\nSystem tests\nSystem tests can also be included with shinytest2. The examples in lap are similar to those in the golem application.\n\ntests/\n├── testthat/\n│   ├── _snaps/\n│   │   ├── app-feature-01\n│   │   └── shinytest2\n│   ├── setup-shinytest2.R\n│   ├── test-app-feature-01.R\n│   └── test-shinytest2.R\n└── testthat.R\n\n5 directories, 13 files\n\n\n\nAdding files and images\nI’ll demonstrate how to use the inst/ folder by adding an image to the application.\n\nAssume I want to add leprechaun.jpg to my UI. I start by adding the file to inst/img/:\n\ninst/\n  └── img/\n       └── leprechaun.jpg &lt;- new image file!\n\nThen I add the img/ path to the code to UI:\n\ntags$img(\n  src = \"img/leprechaun.jpg\",\n  height=\"25%\",\n  width=\"25%\")\n\n\nOnce again, run devtools::load_all() and devtools::document(), restarting and loading the package, then run the application with run()\n\n\n\n\n\n(a)\n\n\nFigure 2: Adding images to inst/img/\n\n\n\n\nAdding resources\nleprechaun stores external code files the inst/ folder (similar to the golem framework), but uses a combination of use_* and build() functions to add functionality to you app.\n\nUsing packer\nTo demonstrate how packer and leprechaun work together, we’ll walk through the JavaScript example from the package website step-by-step:\n\nFirst we have to build the scaffolding for packer by running packer::scaffold_leprechaun():\n\npacker::scaffold_leprechaun()\n\n\npacker::scaffold_leprechaun() initializes the npm package manager for JavaScript, installs webpack, and adds the necessary JavaScript files and folders:\n\n\n── Scaffolding leprechaun ──────────────────────────────────────\n✔ Initialiased npm\n✔ webpack, webpack-cli, webpack-merge installed with scope \"dev\" \n✔ Added npm scripts\n✔ Created srcjs directory\n✔ Created srcjs/config directory\n✔ Created webpack config files\n\n── Adding files to .gitignore and .Rbuildignore ──\n\n✔ Setting active project to '/projects/apps/sfw/_apps/lap'\n✔ Adding '^srcjs$' to '.Rbuildignore'\n✔ Adding '^node_modules$' to '.Rbuildignore'\n✔ Adding '^package\\\\.json$' to '.Rbuildignore'\n✔ Adding '^package-lock\\\\.json$' to '.Rbuildignore'\n✔ Adding '^webpack\\\\.dev\\\\.js$' to '.Rbuildignore'\n✔ Adding '^webpack\\\\.prod\\\\.js$' to '.Rbuildignore'\n✔ Adding '^webpack\\\\.common\\\\.js$' to '.Rbuildignore'\n✔ Adding 'node_modules' to '.gitignore'\n\n── Scaffold built ──\n\nℹ Run `bundle` to build the JavaScript files\nℹ Run `leprechaun::use_packer()`\n\n\nNow that the scaffolding is in place, run leprechaun::use_packer():\n\n\nleprechaun::use_packer()\n\n\n✔ Creating inst/dev/packer.R\n✔ Adding 'packer' to Suggests in DESCRIPTION\n! This requires `leprechaun::build()` or the `leprechaun::build_roclet`\n\nThe final step is to build or ‘bundle’ the JavaScript files with leprechaun::build()\n\nleprechaun::build()\n\n\n✔ Running packer.R\n✔ Bundled       \n\n\nLets review the new files that have been added to the lap:\n\nIn the inst/dev/ folder, the packer.R file has been added, which calls packer::bundle()\n\ninst/dev/\n      └── packer.R\n\n1 directory, 1 file\n\nIn the srcjs/ folder, the modules/message.js and index.js create the alert with Shiny.addCustomMessageHandler\n\nsrcjs/\n    ├── config\n    │   ├── entry_points.json\n    │   ├── externals.json\n    │   ├── loaders.json\n    │   ├── misc.json\n    │   └── output_path.json\n    ├── index.js\n    └── modules\n        └── message.js\n\n// srcjs/modules/message.js\nexport const message = (msg) =&gt; {\n  alert(msg);\n}\n// srcjs/index.js\nimport { message } from './modules/message.js';\nimport 'shiny';\n\n// In shiny server use:\n// session$sendCustomMessage('show-packer', 'hello packer!')\nShiny.addCustomMessageHandler('show-packer', (msg) =&gt; {\n  message(msg.text);\n})\n\nTo use the JS message scripts in srcjs/, I add the following to R/server.R:\n\nIn R/server.R\n\n\n    send_message &lt;- make_send_message(session)\n    send_message(\"show-packer\",\n                  text = \"this message is from your R/server.R file\")\n\nAfter running devtools::load_all() and devtools::document(), the application loads with an alert:\n\n\n\n\n\n(a) send_message() from R/server.R\n\n\nFigure 3: send_message()\n\n\nWe can also include messages from modules.\n\nIn R/module_plot_display.R\n\n\nsend_message &lt;- make_send_message(session)\nsend_message(\"show-packer\",\n  text = \"this is a message from your plot_display module\")\n\nRead more about sending JavaScript messages here on the shiny website.\n\n\nUsing Sass\nWe can add Sass styling to our leprechaun app using the use_sass() helper function (this Sass example is from the package website).\n\nRun leprechaun::use_sass():\n\n\nleprechaun::use_sass()\n\n\nThis will add files to assets/ and dev/ and we see the following messages:\n\n\n✔ Creating scss\n✔ Creating inst/dev/sass.R\n✔ Adding 'sass' to Suggests in DESCRIPTION\n✔ Adding '^scss$' to '.Rbuildignore'\n! This requires `leprechaun::build()` or the `leprechaun::build_roclet`\n\n\nBelow are the new files in scss/:\n\n\nscss\n├── _core.scss\n└── main.scss\n\n1 directory, 2 files\n\nThe scss/ folder created by leprechaun::use_sass() includes _core.scss and main.scss.\n\n_core.scss: the original file is below\n\n\nhtml{\n    .error {\n        color: red\n    }\n}\n\n\nWe’ll change the color: from red to green (#38B44A) using $accent: #38B44A;\n\n\n$accent: #38B44A;\n\nhtml{\n    h1 {\n        color: $accent;\n    }\n}\n\n\nThen run leprechaun::build()\n\n\nleprechaun::build()\n\n\n✔ Running packer.R\n✔ Bundled       \n✔ Running sass.R\n\n\nThe inst/dev/sass.R file contains a sass_build() function\n\nsass_build() looks in the scss/ folder for main.scss and creates the inst/assets/style.min.css file.\n\n\n#' Build CSS\n#'\n#' Build the sass\nsass_build &lt;- function() {\n  has_sass &lt;- requireNamespace(\"sass\", quietly = TRUE)\n\n  if (!has_sass) {\n    warning(\n      \"Requires `sass` package: `install.packages('sass')`\\n\",\n      \"Skipping.\",\n      call. = FALSE\n    )\n    return()\n  }\n\n  output &lt;- sass::sass(\n    sass::sass_file(\n      \"scss/main.scss\"\n    ),\n    cache = NULL,\n    options = sass::sass_options(\n      output_style = \"compressed\"\n    ),\n    output = \"inst/assets/style.min.css\"\n  )\n  invisible(output)\n}\n\nsass_build()\n\n\nOnce again, I run devtools::load_all(), devtools::document(), install and restart, then load the package and run()\n\n\n\n\n\n(a)\n\n\nFigure 4: run lap with new Sass\n\n\n\n\n\nleprechaun::build()\nThe assets/ folder contains the files generated by the .R scripts in the dev/ folder.\n\n“Do not call this function from within the app. It helps build things, not run them.” - build.md guide\n\n\nContents of inst/assets/:\n\ninst/assets/\n        ├── index.js\n        └── style.min.css\n\n1 directory, 2 files\n\nContents of inst/dev/:\n\ninst/dev/\n      ├── packer.R\n      └── sass.R\n\n1 directory, 2 files\n\ninst/dev/sass.R creates inst/assets/style.min.css and inst/dev/packer.R creates inst/assets/index.js\n\n\nserveAssets()\nAfter running leprechaun::use_sass() and leprechaun::build(), we’ll check the serveAssets() function:\n\nlap:::serveAssets()\n\n\n[[1]]\nList of 10\n $ name      : chr \"lap\"\n $ version   : chr \"0.0.0.9000\"\n $ src       :List of 1\n  ..$ file: chr \".\"\n $ meta      : NULL\n $ script    : Named chr \"assets/index.js\"\n  ..- attr(*, \"names\")= chr \"file\"\n $ stylesheet: Named chr [1:2] \"assets/style.min.css\" \"html/R.css\"\n  ..- attr(*, \"names\")= chr [1:2] \"file\" \"file\"\n $ head      : NULL\n $ attachment: NULL\n $ package   : chr \"lap\"\n $ all_files : logi TRUE\n - attr(*, \"class\")= chr \"html_dependency\"\n\nThis shows me stylesheet has been updated with \"assets/style.min.css\" and script has been updated with \"assets/index.js\" (these files are loaded into the application when it runs).\n\n\n\nConfigure\nleprechaun app configuration files use the config package (similar to golem). leprechaun doesn’t assume I’ll be using a config.yml file, but I can easily add one with leprechaun::use_config().\n\nuse_config() adds a inst/config.yml and R/config.R\nThe default value in the config.yml files is production: true, which can be read using config_read() in R/config.R.\n\nconfig_read()\n\n\n$production\n[1] TRUE\n\n\nValues can be added to inst/config.yml using the config file format, then the CONFIG_FILE can be set as an environmental variable"
  },
  {
    "objectID": "leprechaun.html#dependencies",
    "href": "leprechaun.html#dependencies",
    "title": "The leprechaun framework",
    "section": "Dependencies",
    "text": "Dependencies\n\n\n\n\n\n\nWhat does ‘leaner and smaller’ mean?\n\n\n\n\n\n\nleprechaun doesn’t add itself as a dependency (i.e., no need to add leprechaun to the list of Imports in the DESCRIPTION or NAMESPACE).\nThe section titled, ‘the golem in the room’ on the package website is worth reading because it covers the differences between the two packages (and why you might choose one over the other).\n\n\n\n\nThe final folder tree for lap (a leprechaun app-package) are below:\n\n├── DESCRIPTION\n├── NAMESPACE\n├── R/\n│   ├── _disable_autoload.R\n│   ├── assets.R\n│   ├── config.R\n│   ├── endpoint-utils.R\n│   ├── html-utils.R\n│   ├── input-handlers.R\n│   ├── leprechaun-utils.R\n│   ├── module_plot_display.R\n│   ├── module_var_input.R\n│   ├── run.R\n│   ├── server.R\n│   ├── ui.R\n│   ├── utils-js.R\n│   ├── utils_scatter_plot.R\n│   └── zzz.R\n├── README.md\n├── app.R\n├── data/\n│   └── movies.rda\n├── data-raw/\n│   └── movies.R\n├── inst/\n│   ├── assets\n│   ├── config.yml\n│   ├── dev\n│   ├── extdata\n│   ├── img\n│   └── run\n├── lap.Rproj\n├── node_modules/ \n├── package-lock.json\n├── package.json\n├── scss/\n│   ├── _core.scss\n│   └── main.scss\n├── srcjs/\n│   ├── config\n│   ├── index.js\n│   ├── leprechaun-utils.js\n│   └── modules\n├── tests/\n│   ├── testthat\n│   └── testthat.R\n├── webpack.common.js\n├── webpack.dev.js\n└── webpack.prod.js\n\n109 directories, 63 files\n\nThe packer::\nlap depends on shiny, but not leprechaun.\n\npak::local_dev_deps_explain(\n  deps = \"shiny\", \n  root = \"_apps/lap\")\n\n lap -&gt; shiny\n\n lap -&gt; shinytest2 -&gt; shiny\n\n\npak::local_dev_deps_explain(\n  deps = \"leprechaun\", \n  root = \"_apps/lap\")\n\n x leprechaun\n\nHowever, adding functionality and features with the use_* functions can add dependencies to your leprechaun app:\n\npak::local_dev_deps_explain(\n  deps = \"sass\", \n  root = \"_apps/lap\")\n\n lap -&gt; bslib -&gt; sass\n\n lap -&gt; shiny -&gt; bslib -&gt; sass\n\n lap -&gt; packer -&gt; htmlwidgets -&gt; rmarkdown -&gt;\n\n   bslib -&gt; sass\n\n lap -&gt; sass\n\n lap -&gt; shinytest2 -&gt; rmarkdown -&gt; bslib -&gt;\n\n   sass\n\n lap -&gt; shinytest2 -&gt; shiny -&gt; bslib -&gt; sass\n\n\nleprechaun apps are packages, so the inst/ folders are available to the application at runtime (which I can find using system.file()).\n\nBelow I’ve passed the output from system.file(\".\", package = \"lap\") to fs::dir_tree() to view it’s contents:\n\n\n├── DESCRIPTION\n├── INDEX\n├── Meta/\n│   ├── Rd.rds\n│   ├── data.rds\n│   ├── features.rds\n│   ├── hsearch.rds\n│   ├── links.rds\n│   ├── nsInfo.rds\n│   └── package.rds\n├── NAMESPACE\n├── R/\n│   ├── lap\n│   ├── lap.rdb\n│   └── lap.rdx\n├── assets/\n│   ├── index.js\n│   └── style.min.css\n├── data/\n│   ├── Rdata.rdb\n│   ├── Rdata.rds\n│   └── Rdata.rdx\n├── dev/\n│   ├── packer.R\n│   └── sass.R\n├── extdata/\n│   └── movies.RData\n├── help/\n│   ├── AnIndex\n│   ├── aliases.rds\n│   ├── lap.rdb\n│   ├── lap.rdx\n│   └── paths.rds\n├── html/\n│   ├── 00Index.html\n│   └── R.css\n├── img/\n│   └── leprechaun.jpg\n└── run/\n    └── app.R\n\n\nI can see the inst/ folders and files I’ve created are available to lap at runtime"
  },
  {
    "objectID": "leprechaun.html#recap",
    "href": "leprechaun.html#recap",
    "title": "The leprechaun framework",
    "section": "Recap",
    "text": "Recap\nleprechaun delivers on its promise to be a ‘leaner and smaller’ version of golem.\nMost of the features in golem are also accessible in leprechaun:\n\nAdding modules: leprechaun’s add_module() function doesn’t have the consistent naming or prefixes found in golem::add_module(), but still reduces a lot of typing if you are creating these files manually.\nAdding functions: leprechaun relies on usethis::use_r() for adding new functionality to your application\nleprechaun doesn’t come with any testing functions, although this can be done using testthat and shinytest2 (just as we would with a standard R package).\n\nMultiple inst/ sub-folders makes adding assets to the application easier, and leprechaun has a long list of use_* functions for including Sass, CSS, HTML, and JavaScript. The package website has examples for getting started and adding multiple resources, but unfortunately the function reference had limited documentation.\nBelow is an overview of the features/functions in the leprechaun framework:\n\n\n\n\nFeature\nArguments/Options\nDescription/Comments\n\n\n\n\nscaffold()\nui: can be one of \"navbarPage\" or \"fluidPage\"\nbs_version: Bootstrap version\noverwrite : recreate folder structure\nThe initial ‘setup’ function that builds the leprechaun files in R/ and inst/\n\n\nscaffold_leprechaun() (from packer)\nreact : include React?\nvue : include Vue?\nuse_cdn : use the CDN for react or vue dependencies?\nedit : open pertinent files\nThis function comes from the packer package for integrating JS with R.\nThis creates the following non-standard R package folders and files:\n\nsrcjs/ and node_modules/\npackage-lock.json, package.json, webpack.common.js, webpack.dev.js, and webpack.prod.js files\n\nThese non-standard folders are added to the .Rbuildignore and .gitignore (but it would be nice to know more about what they do).\n\n\nuse_packer()\nAssumes scaffold_leprechaun() from packer has been run\nSets up application to use packer utilities for bundling JavaScript.\n\nCreates inst/dev/packer.R\nAdds packer to Suggests in DESCRIPTION\n\n\n\nbuild()\nReturns TRUE/FALSE if build was successful.\nUsed to ‘bundle’ various resources (i.e., from packer and the other use_ functions)\n\n\nuse_sass()\n\nCreates inst/dev/sass.R\nAdds sass to DESCRIPTION under Suggests\n\n\nuse_html_utils()\nAdds R/html-utils.R\nAdds htmltools to Imports field in DESCRIPTION\nR/html-utils.R contains a variety of utility functions using HTML tags (i.e., span(), div(), etc.)\n\n\nuse_endpoints_utils()\nAdds R/endpoint-utils.R\nAdds jsonlite to Imports field in DESCRIPTION\nR/endpoint-utils.R contains utility functions for creating an HTTP response object and the LEPRECHAUN_SERIALISER environmental variable.\n\n\nuse_js_utils()\nAdds srcjs/leprechaun-utils.js and R/utils-js.R\nAdds import statement to srcjs/index.js\nRequires running leprechaun::build() to bundle .js\n\n\nuse_config()\nAdds R/config.R and inst/config.yml\ninst/config.yml initially contains production: true\nAdds yml to Imports field in DESCRIPTION\nR/config.R contains functions for reading and getting configuration values.\n\n\nadd_module()\nUsing add_module(\"name\") :\n\nCreates R/module_name.R\nUI function: nameUI()\nServer function: name_server()\n\nIt would be nice if the modules had consistent naming (the UI function uses camelCase() and the server function is snake_case()).\nBy default, modules aren’t exported (i.e., with @export), but are included in the package index (i.e., with @keywords internal)\nEach module automatically includes:\nsend_message &lt;- make_send_message(session)\n\n\nadd_app_file()\nAdds app.R file to root directory.\nIncludes call to pkgload::load_all() with reset set to TRUE and helpers set to FALSE\nHandy for quickly launching the app during development (and deployment).\n\n\n.onLoad()\nUsed to add external files to app (images, html, etc.)\nCombines Shiny’s addResourcePath() and system.file().\n\n\nserveAssets()\nmodules argument can be used to include JavaScript modules\nAdds dependencies for JavaScript, CSS, and HTML."
  },
  {
    "objectID": "leprechaun.html#footnotes",
    "href": "leprechaun.html#footnotes",
    "title": "The leprechaun framework",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nDownload the code used to build the leprechaun app here↩︎\nThe leprechaun::scaffold() defaults to a navbarPage(), but I’ve switched to a fluidPage() for this example.↩︎\ntestthat can be used for testing utility functions and module functions (as shown here).↩︎"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Shiny Frameworks",
    "section": "",
    "text": "This website is a resource for developers to get an ‘under the hood’ view of three popular Shiny frameworks.\n\n\n\n\n\n\n\n\n\n\ngap: a golem app-package (download gap)\n\n\n\n\n\n\n\n\n\n\n\n\n\nlap: a leprechaun app-package (download lap)\n\n\n\n\n\n\n\n\n\n\n\n\n\nrap: a rhino app (pseudo-package)1 (download rap)"
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Shiny Frameworks",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nrhino apps aren’t R packages–they’re dependencies are managed with a dependencies.R file and box modules.↩︎\nThis was a popular course among colleagues and covers (in my opinion) what a developer should know before considering a framework.↩︎\nYou can download the movies data here.↩︎"
  }
]